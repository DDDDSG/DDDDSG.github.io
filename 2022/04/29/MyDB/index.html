<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本项目使⽤ Java 语⾔实现了⼀个简易的数据库。MYDB 分为后端和前端，前后端通过 socket 进行交互。前端（客户端）负责读取⽤户输⼊，并发送到后端执⾏，输出返回结果，并等待下⼀次输⼊。MYDB 后端则需要解析 SQL，如果是合法的 SQL，就尝试执⾏并返回结果。">
<meta property="og:type" content="article">
<meta property="og:title" content="MyDB数据库">
<meta property="og:url" content="http://example.com/2022/04/29/MyDB/index.html">
<meta property="og:site_name" content="U Boy TT">
<meta property="og:description" content="本项目使⽤ Java 语⾔实现了⼀个简易的数据库。MYDB 分为后端和前端，前后端通过 socket 进行交互。前端（客户端）负责读取⽤户输⼊，并发送到后端执⾏，输出返回结果，并等待下⼀次输⼊。MYDB 后端则需要解析 SQL，如果是合法的 SQL，就尝试执⾏并返回结果。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/imags/006VKfGmly8gwtst971hvj30bx0feq34.jpg">
<meta property="article:published_time" content="2022-04-29T11:03:34.844Z">
<meta property="article:modified_time" content="2022-08-02T13:38:13.265Z">
<meta property="article:author" content="TT">
<meta property="article:tag" content="项目">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/imags/006VKfGmly8gwtst971hvj30bx0feq34.jpg">

<link rel="canonical" href="http://example.com/2022/04/29/MyDB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>MyDB数据库 | U Boy TT</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">U Boy TT</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>资源</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/29/MyDB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="TT">
      <meta itemprop="description" content="All troubles are self-inflicted.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="U Boy TT">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MyDB数据库
        </h1>

        <div class="post-meta">

	
  	<i class="fa fa-thumb-tack"></i>
  	<font color=7D26CD>置顶</font>
 	 <span class="post-meta-divider">|</span>
	
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-29 19:03:34" itemprop="dateCreated datePublished" datetime="2022-04-29T19:03:34+08:00">2022-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-02 21:38:13" itemprop="dateModified" datetime="2022-08-02T21:38:13+08:00">2022-08-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E5%8F%8A%E6%95%B4%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">项目学习及整理</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>62k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>56 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本项目使⽤ Java 语⾔实现了⼀个简易的数据库。MYDB 分为后端和前端，前后端通过 socket 进行交互。前端（客户端）负责读取⽤户输⼊，并发送到后端执⾏，输出返回结果，并等待下⼀次输⼊。MYDB 后端则需要解析 SQL，如果是合法的 SQL，就尝试执⾏并返回结果。 </p>
<span id="more"></span>

<h1 id="MyDB-简介"><a href="#MyDB-简介" class="headerlink" title="MyDB 简介"></a>MyDB 简介</h1><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>​		MYDB 分为后端和前端，前后端通过 socket 进行交互。前端（客户端）的职责很单一，读取用户输入，并发送到后端执行，输出返回结果，并等待下一次输入。MYDB 后端则需要解析 SQL，如果是合法的 SQL，就尝试执行并返回结果。不包括解析器，MYDB 的后端划分为五个模块，每个模块都又一定的职责，通过接口向其依赖的模块提供方法。	</p>
<p>​		以下是各个模块的介绍： </p>
<p>​		<strong>Transaction Manager</strong>– TM: begin, commit(T), abort(T), isActive(T),isCommitted(T),isAborted(T) TM提供了针对事务的开始, 提交, 回滚操作, 同时提供了对数据项状态的查询操作	</p>
<p>​		<strong>Data Manager</strong>– DM: insert(x), update(x), read(x) DM提供了针对数据项(data item)的基本插入, 更新, 读取操作, 且这些操作是原子性的. DM会直接对数据库文件进行读写</p>
<p>​		<strong>Version Manager</strong>– VM: insert(X), update(X), read(X), delete(X) VM提供了针对记录(entry)的增删查改操作, VM在内部为每条记录维护多个版本, 并根据不同的事务, 返回不同的版本. VM对这些实现, 是建立在DM和TM的各个操作上的，还有一个事务可见性类Visibility</p>
<p>​		<strong>Table Manage</strong>r– TBM: execute(statement) TBM就是非常高层的模块了, 他能直接执行用户输入的语句(statement), 然后进行执行. TBM对语句的执行是建立在VM和IM提供的各个操作上的.</p>
<p>​		<strong>Index Manager</strong>– IM: value search(key), insert(key, value) IM提供了对索引的基本操作</p>
<p>五个模块的依赖关系如下：</p>
<p><img src="/../imags/006VKfGmly8gwtst971hvj30bx0feq34.jpg" alt="006VKfGmly8gwtst971hvj30bx0feq34"></p>
<h2 id="所需知识点"><a href="#所需知识点" class="headerlink" title="所需知识点"></a>所需知识点</h2><p>​		RandomAccessFile 类，随机存取文件流</p>
<p>​				RandomAccessFile 类支持 任意访问，即程序可以直接跳到文件的任意地方来读、写文件。</p>
<p>​				API：new RandomAccessFile (文件地址&#x2F;文件名,读取模式)、seek(位置)类似于fc.position方法</p>
<p>​		NIO：本项目所用网络IO模型为非阻塞IO</p>
<p>​				API：Channel通道负责传输，常用FileChannel处理本地文件</p>
<p>​						  Buffer缓冲区负责存储，byteBuffer</p>
<p>​						  Selector处理socket连接</p>
<h1 id="从最简单的-TM-开始"><a href="#从最简单的-TM-开始" class="headerlink" title="从最简单的 TM 开始"></a>从最简单的 TM 开始</h1><p>​		TransactionManager 通过维护<strong>一个</strong> XID 格式文件来维护记录事务的状态（active 正在进行尚未提交，committed 已提交，aborted 已撤销&#x2F;回滚），并提供接口供其他模块来查询某个事务的状态。</p>
<h2 id="XID-文件简介"><a href="#XID-文件简介" class="headerlink" title="XID 文件简介"></a>XID 文件简介</h2><p>​		XID 文件定义：MyBD 中，每一个事务都对应着一个 xid，通过 id 唯一标识这个事务。XID 0 是特殊事务，称为 super Transaction,它的事务状态永远是 committed。正常事务的 XID 从 1 开始，自增且不可重复。</p>
<p>​		XID 文件给每个事务分配了一个字节的空间用来保存其状态，XID 文件的头部开辟了8字节的空间用来记录该 XID 管理的事务个数。于是，事务 xid 在文件中的状态就存储在 (xid-1)+8 字节处，xid-1 是因为 xid 0（Super XID） 的状态不需要记录。</p>
<h3 id="创建TM接口"><a href="#创建TM接口" class="headerlink" title="创建TM接口"></a>创建TM接口</h3><p>​		用来创建事务和查询事务状态。也实现了 create XID文件和 open XID文件的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionManager</span> &#123;     </span><br><span class="line">    <span class="type">long</span> <span class="title function_">begin</span><span class="params">()</span>;                       <span class="comment">// 开启一个新事务    </span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span>;              <span class="comment">// 提交一个事务    </span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">long</span> xid)</span>;               <span class="comment">// 取消一个事务    </span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isActive</span><span class="params">(<span class="type">long</span> xid)</span>;         <span class="comment">// 查询一个事务的状态是否是正在进行的状态   </span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCommitted</span><span class="params">(<span class="type">long</span> xid)</span>;      <span class="comment">// 查询一个事务的状态是否是已提交    </span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAborted</span><span class="params">(<span class="type">long</span> xid)</span>;        <span class="comment">// 查询一个事务的状态是否是已取消    </span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;                       <span class="comment">// 关闭TM </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建名为path的文件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TransactionManagerImpl <span class="title function_">create</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义文件的文件名为：路径+后缀</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path+TransactionManagerImpl.XID_SUFFIX);</span><br><span class="line">	   <span class="comment">// 判断该文件不能创建新文件或者不能读或写</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!f.createNewFile()) &#123;</span><br><span class="line">                Panic.panic(Error.FileExistsException);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!f.canRead() || !f.canWrite()) &#123;</span><br><span class="line">            Panic.panic(Error.FileCannotRWException);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fc</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建XID文件 和 连接IO设备的通道</span></span><br><span class="line">            raf = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(f, <span class="string">&quot;rw&quot;</span>);<span class="comment">//rw	读操作和写操作都是允许的</span></span><br><span class="line">            fc = raf.getChannel();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">           Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写空XID文件头</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="keyword">new</span> <span class="title class_">byte</span>[TransactionManagerImpl.LEN_XID_HEADER_LENGTH]);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fc.position(<span class="number">0</span>);</span><br><span class="line">            fc.write(buf);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回经过校验的XID文件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransactionManagerImpl</span>(raf, fc);</span><br><span class="line">    &#125;	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打开名为path的文件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TransactionManagerImpl <span class="title function_">open</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        <span class="comment">// 文件名为：path+后缀</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path+TransactionManagerImpl.XID_SUFFIX);</span><br><span class="line">        <span class="keyword">if</span>(!f.exists()) &#123;</span><br><span class="line">            Panic.panic(Error.FileNotExistsException);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!f.canRead() || !f.canWrite()) &#123;</span><br><span class="line">            Panic.panic(Error.FileCannotRWException);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fc</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            raf = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(f, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">            fc = raf.getChannel();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">           Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回经过校验的XID文件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransactionManagerImpl</span>(raf, fc);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="1-定义常量和属性"><a href="#1-定义常量和属性" class="headerlink" title="1.定义常量和属性"></a>1.定义常量和属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XID文件头长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LEN_XID_HEADER_LENGTH</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 每个事务的占用长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">XID_FIELD_SIZE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 事务的三种状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_ACTIVE</span>   <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_COMMITTED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">FIELD_TRAN_ABORTED</span>  <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 超级事务，永远为commited状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SUPER_XID</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// XID 文件后缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">XID_SUFFIX</span> <span class="operator">=</span> <span class="string">&quot;.xid&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>文件写都采用了 NIO 方式的 FileChannel通信管道。文件采用RandomAccessFile的API。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NIO方式的FileChannel</span></span><br><span class="line"><span class="keyword">private</span> RandomAccessFile file;<span class="comment">// 用RAF类的API，对XID的文件进行操作</span></span><br><span class="line"><span class="keyword">private</span> FileChannel fc;<span class="comment">// FileChannel主要用于文件传输</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> xidCounter;<span class="comment">// id计数</span></span><br><span class="line"><span class="keyword">private</span> Lock counterLock;<span class="comment">// 锁</span></span><br></pre></td></tr></table></figure>

<h3 id="2-校验-XID-文件保证其合法性"><a href="#2-校验-XID-文件保证其合法性" class="headerlink" title="2.校验 XID 文件保证其合法性"></a>2.校验 XID 文件保证其合法性</h3><p>​		在创建 TransactionManager 之后，首先需要校验 XID 文件保证其合法性，通过文件头 8 字节数字反推文件的理论长度，与实际长度做对比。对于校验没有通过的，会直接通过 panic 方法，强制停机。在一些基础模块中出现错误都会如此处理，无法恢复的错误只能直接停机。</p>
<p>在校验前，需要 getXidPosition 方法，来获取xid的状态在文件中的偏移。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据事务xid取得其在XID文件中对应的位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getXidPosition</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> LEN_XID_HEADER_LENGTH + (xid-<span class="number">1</span>)*XID_FIELD_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>校验 XID 文件保证其合法性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// raf 和 fc 由 create()方法调用</span></span><br><span class="line">TransactionManagerImpl(RandomAccessFile raf, FileChannel fc) &#123;</span><br><span class="line">    <span class="built_in">this</span>.file = raf;</span><br><span class="line">    <span class="built_in">this</span>.fc = fc;</span><br><span class="line">    counterLock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    checkXIDCounter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检查XID文件是否合法</span></span><br><span class="line"><span class="comment">         * 通过文件头 8 字节数字反推文件的理论长度，与实际长度做对比</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkXIDCounter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">fileLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 文件实际长度</span></span><br><span class="line">        fileLen = file.length();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">        Panic.panic(Error.BadXIDFileException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断实际长度是否大于文件头8字节长度</span></span><br><span class="line">    <span class="keyword">if</span>(fileLen &lt; LEN_XID_HEADER_LENGTH) &#123;</span><br><span class="line">        Panic.panic(Error.BadXIDFileException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// allocate(capacity);创建缓冲区并确定大小</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(LEN_XID_HEADER_LENGTH);<span class="comment">// 缓冲区大小为8 字节</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// position();获取FileChannel的当前位置，进行读写操作</span></span><br><span class="line">        fc.position(<span class="number">0</span>); <span class="comment">// 0 表示可以读取全部数据</span></span><br><span class="line">        <span class="comment">// 把FileChannel的数据读取到缓冲区中</span></span><br><span class="line">        fc.read(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从缓冲区取出数据，赋值给xidCounter</span></span><br><span class="line">    <span class="built_in">this</span>.xidCounter = Parser.parseLong(buf.array());</span><br><span class="line">    <span class="comment">// 根据xidCounter获取其在XID文件中对应的位置（）</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> getXidPosition(<span class="built_in">this</span>.xidCounter + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 反推长度与实际长度对比</span></span><br><span class="line">    <span class="keyword">if</span>(end != fileLen)&#123;</span><br><span class="line">        Panic.panic(Error.BadXIDFileException);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于校验没有通过的，会直接通过 panic 方法，强制停机。在一些基础模块中出现错误都会如此处理，无法恢复的错误只能直接停机。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Panic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">panic</span><span class="params">(Exception err)</span> &#123;</span><br><span class="line">        err.printStackTrace();</span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-更新事务状态方法和更新XID文件头方法"><a href="#3-更新事务状态方法和更新XID文件头方法" class="headerlink" title="3.更新事务状态方法和更新XID文件头方法"></a>3.更新事务状态方法和更新XID文件头方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新xid事务的状态为传入的status</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateXID</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span> status)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取xid的在XID文件中的位置</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> getXidPosition(xid);</span><br><span class="line">        <span class="comment">// 创建字符数组，第一位表示传入的xid事务的状态</span></span><br><span class="line">        <span class="type">byte</span>[] tmp = <span class="keyword">new</span> <span class="title class_">byte</span>[XID_FIELD_SIZE];</span><br><span class="line">        tmp[<span class="number">0</span>] = status;</span><br><span class="line">        <span class="comment">// 通过包装的方法创建的缓冲区，保留了被包装数组内保存的数据</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(tmp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 下一个读写位置的索引是xid在XID文件中的位置</span></span><br><span class="line">            fc.position(offset);<span class="comment">// 读取到的是未修改前的状态</span></span><br><span class="line">            <span class="comment">//  buffer中的内容全部写入channel</span></span><br><span class="line">            fc.write(buf);<span class="comment">// 修改状态为形参传入的状态</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// force() ;强制同步缓存内容到文件中</span></span><br><span class="line">            fc.force(<span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将XID加一，并更新XID文件Header</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">incrXIDCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// xid数量+1</span></span><br><span class="line">        xidCounter ++;</span><br><span class="line">        <span class="comment">// 创建xid数量大小的缓冲区</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(Parser.long2Byte(xidCounter));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// fc下次写读位置为0，即XID文件文件头位置</span></span><br><span class="line">            fc.position(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 把bf的数据写入fc</span></span><br><span class="line">            fc.write(buf);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fc.force(<span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-创建-begin-事务方法、创建提交事务方法、创建回滚事务方法"><a href="#4-创建-begin-事务方法、创建提交事务方法、创建回滚事务方法" class="headerlink" title="4.创建 begin 事务方法、创建提交事务方法、创建回滚事务方法"></a>4.创建 begin 事务方法、创建提交事务方法、创建回滚事务方法</h3><p>​		会开始一个事务（事务状态为正在进行 active），更具体的，首先设置 xidCounter+1 事务的状态为 committed，随后 xidCounter 自增，并更新文件头。</p>
<p>​		创建提交事务方法、创建回滚事务方法，直接调用updateXID(xid,status);即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始一个事务，并返回 XID</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">begin</span><span class="params">()</span> &#123;</span><br><span class="line">    counterLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> xidCounter + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 更新事务状态为 active</span></span><br><span class="line">        updateXID(xid, FIELD_TRAN_ACTIVE);</span><br><span class="line">        <span class="comment">// 更新 XID 文件文件头</span></span><br><span class="line">        incrXIDCounter();</span><br><span class="line">        <span class="keyword">return</span> xid;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        counterLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    <span class="comment">// 更新xid事务的状态</span></span><br><span class="line">    updateXID(xid, FIELD_TRAN_COMMITTED); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回滚事务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    <span class="comment">// 更新xid事务的状态</span></span><br><span class="line">    updateXID(xid, FIELD_TRAN_ABORTED); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-创建-isActive、isCommitted-和-isAborted-方法"><a href="#5-创建-isActive、isCommitted-和-isAborted-方法" class="headerlink" title="5.创建 isActive、isCommitted 和 isAborted 方法"></a>5.创建 isActive、isCommitted 和 isAborted 方法</h3><p>​		以上三个方法都是检查某个事务 id 的状态，可以用一个通用的方法 checkXID 解决。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测xid事务是否处于某种状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkXID</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span> status)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> getXidPosition(xid);</span><br><span class="line">    <span class="comment">// wrap();创建缓冲区，并保留了数组内的数据</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="keyword">new</span> <span class="title class_">byte</span>[XID_FIELD_SIZE]);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fc.position(offset);</span><br><span class="line">        fc.read(buf);<span class="comment">// fc位置的数据写入 buf</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 比较 buf 中byte数组[0] 与 传入参数 status 的值</span></span><br><span class="line">    <span class="keyword">return</span> buf.array()[<span class="number">0</span>] == status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断事务是否处于正在进行状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isActive</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    <span class="comment">// 超级事务不需要记录状态</span></span><br><span class="line">    <span class="keyword">if</span>(xid == SUPER_XID) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> checkXID(xid, FIELD_TRAN_ACTIVE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断事务是否处于已提交状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCommitted</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(xid == SUPER_XID) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> checkXID(xid, FIELD_TRAN_COMMITTED);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断事务是否处于已撤销状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAborted</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(xid == SUPER_XID) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> checkXID(xid, FIELD_TRAN_ABORTED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-关闭资源"><a href="#6-关闭资源" class="headerlink" title="6.关闭资源"></a>6.关闭资源</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 关闭管道和文件</span></span><br><span class="line">        fc.close();</span><br><span class="line">        file.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7、接口静态方法"><a href="#7、接口静态方法" class="headerlink" title="7、接口静态方法"></a>7、接口静态方法</h3><p>​		create();创建一个 xid 文件并创建 TM 	open();从一个已有的 xid 文件来创建 TM。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建名为path的文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TransactionManagerImpl <span class="title function_">create</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义文件的文件名为：路径+后缀</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path+TransactionManagerImpl.XID_SUFFIX);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断该文件不能创建新文件或者不能读或写</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!f.createNewFile()) &#123;</span><br><span class="line">            Panic.panic(Error.FileExistsException);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!f.canRead() || !f.canWrite()) &#123;</span><br><span class="line">        Panic.panic(Error.FileCannotRWException);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fc</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建XID文件</span></span><br><span class="line">        raf = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(f, <span class="string">&quot;rw&quot;</span>);<span class="comment">//rw	读操作和写操作都是允许的</span></span><br><span class="line">        <span class="comment">// 创建连接IO设备的通道</span></span><br><span class="line">        fc = raf.getChannel();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写空XID文件头</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="keyword">new</span> <span class="title class_">byte</span>[TransactionManagerImpl.LEN_XID_HEADER_LENGTH]);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fc.position(<span class="number">0</span>);</span><br><span class="line">        fc.write(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回经过校验的XID文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransactionManagerImpl</span>(raf, fc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开名为path的文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TransactionManagerImpl <span class="title function_">open</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="comment">// 文件名为：path+后缀</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path+TransactionManagerImpl.XID_SUFFIX);</span><br><span class="line">    <span class="comment">// 判断该文件名是否存在，新文件或者不能读或写</span></span><br><span class="line">    <span class="keyword">if</span>(!f.exists()) &#123;</span><br><span class="line">        Panic.panic(Error.FileNotExistsException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!f.canRead() || !f.canWrite()) &#123;</span><br><span class="line">        Panic.panic(Error.FileCannotRWException);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fc</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        raf = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(f, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        fc = raf.getChannel();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回经过校验的XID文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransactionManagerImpl</span>(raf, fc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="引用计数缓存框架和共享内存数组"><a href="#引用计数缓存框架和共享内存数组" class="headerlink" title="引用计数缓存框架和共享内存数组"></a>引用计数缓存框架和共享内存数组</h1><p>​		DM 直接管理数据库 DB 文件和日志文件。DM 的主要职责有：1) 分页管理 DB 文件，并进行缓存；2) 管理日志文件，保证在发生错误时可以根据日志进行恢复；3) 抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。</p>
<p>​		本节主要实现引用计数缓存框架和共享内存数组，为后面的 DM 向上向下模块设计做铺垫。</p>
<h2 id="实现引用计数策略的缓存框架"><a href="#实现引用计数策略的缓存框架" class="headerlink" title="实现引用计数策略的缓存框架"></a>实现引用计数策略的缓存框架</h2><h3 id="1、抽象方法：不在缓存的资源获取，被驱逐的资源写回"><a href="#1、抽象方法：不在缓存的资源获取，被驱逐的资源写回" class="headerlink" title="1、抽象方法：不在缓存的资源获取，被驱逐的资源写回"></a>1、抽象方法：不在缓存的资源获取，被驱逐的资源写回</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当资源不在缓存时的获取行为</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当资源被驱逐时的写回行为</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">releaseForCache</span><span class="params">(T obj)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2、get-获取资源方法"><a href="#2、get-获取资源方法" class="headerlink" title="2、get();获取资源方法"></a>2、get();获取资源方法</h3><p>​		三部分：检查其他线程、缓存中获取、数据源中获取、</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程场景下，需要记录哪些资源正在从数据源获取</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Long, T&gt; cache;                     <span class="comment">// 实际缓存的数据</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Long, Integer&gt; references;          <span class="comment">// 元素的引用个数</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Long, Boolean&gt; getting;             <span class="comment">// 正在被获取的资源</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> maxResource;                            <span class="comment">// 缓存的最大缓存资源数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;                              <span class="comment">// 缓存中元素的个数</span></span><br><span class="line"><span class="keyword">private</span> Lock lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">get</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    类似CAS底层源码会先进入死循环，无限尝试从缓存中获取数据。</span></span><br><span class="line"><span class="comment">    在获取之前，需要检查是否有其他线程正在从数据源获取这个资源。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">// 判断该资源的 key(线程名？) 在 MAP 中是否有 key 存在</span></span><br><span class="line">        <span class="keyword">if</span>(getting.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 请求的资源正在被其他线程获取</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        资源在缓存中，直接获取并返回，资源引用数+1</span></span><br><span class="line"><span class="comment">        在getting资源中备注，线程准备从数据源获取该资源了</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(cache.containsKey(key)) &#123;<span class="comment">// 资源在缓存中，直接返回</span></span><br><span class="line">            <span class="comment">// 直接Map.get获取</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">            references.put(key, references.get(key) + <span class="number">1</span>);<span class="comment">// Map.put修改资源引用数+1</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">        资源不在缓存中，线程准备从数据源获取该资源。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 先判断缓存满没满，满了获取来也装不下数据</span></span><br><span class="line">        <span class="keyword">if</span>(maxResource &gt; <span class="number">0</span> &amp;&amp; count == maxResource) &#123;<span class="comment">// 缓存的最大缓存资源数&gt;0 ，并且=缓存中元素的个数</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="keyword">throw</span> Error.Cach‘eFullException;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 缓存没满</span></span><br><span class="line">        count ++;	<span class="comment">// 缓存中元素的个数+1</span></span><br><span class="line">        <span class="comment">// value改为true代表该资源可以被线程获取</span></span><br><span class="line">        getting.put(key, <span class="literal">true</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    资源在数据源中，直接调用抽象方法（getForCache）获取</span></span><br><span class="line"><span class="comment">    获取完，删除正在被获取的资源的key</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 资源不在缓存的资源获取</span></span><br><span class="line">        obj = getForCache(key);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">// 缓存中元素的个数-1？</span></span><br><span class="line">        count --;</span><br><span class="line">        <span class="comment">// 删除已经被获取过的 待获取资源的 key</span></span><br><span class="line">        getting.remove(key);</span><br><span class="line">        lock.unlock();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock.lock();</span><br><span class="line">    getting.remove(key);</span><br><span class="line">    <span class="comment">// 获取到的数据存入实际缓存</span></span><br><span class="line">    cache.put(key, obj);</span><br><span class="line">    <span class="comment">// 创建该数据的引用，并设置为 1</span></span><br><span class="line">    references.put(key, <span class="number">1</span>);</span><br><span class="line">    lock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、release-释放缓存方法"><a href="#3、release-释放缓存方法" class="headerlink" title="3、release();释放缓存方法"></a>3、release();释放缓存方法</h3><p>​		release();，用于在上册模块不使用某个资源时，释放对资源的引用。当引用归零时，缓存就会驱逐这个资源。		</p>
<p>​		释放一个缓存，需要 references-1，如果 references-1 &#x3D;&#x3D; 0，就可以回源（资源刷回数据源），并删除缓存所有相关结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(<span class="type">long</span> key)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ref</span> <span class="operator">=</span> references.get(key)-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 引用归零，可以回源（资源刷回数据源），并删除缓存所有相关结构。</span></span><br><span class="line">        <span class="keyword">if</span>(ref == <span class="number">0</span>) &#123;</span><br><span class="line">            </span><br><span class="line">          	<span class="comment">// 刷回数据源</span></span><br><span class="line">            <span class="comment">// 获取缓存中的key</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">            <span class="comment">// 被驱逐资源的写回</span></span><br><span class="line">            releaseForCache(obj);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 删除缓存结构，包括引用结构、缓存数据，缓存中元素的个数-1</span></span><br><span class="line">            references.remove(key);</span><br><span class="line">            cache.remove(key);</span><br><span class="line">            count --;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ref 减 1 后，引用不归零，别的线程仍在使用该元素</span></span><br><span class="line">            references.put(key, ref);<span class="comment">// 把减 1 的数据存入引用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、close-关闭缓存方法"><a href="#4、close-关闭缓存方法" class="headerlink" title="4、close();关闭缓存方法"></a>4、close();关闭缓存方法</h3><p>​		关闭缓存，需要将缓存中的所有资源强行回源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭缓存，把数据全部写回资源源</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历缓存所有的key</span></span><br><span class="line">        Set&lt;Long&gt; keys = cache.keySet();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> key : keys) &#123;</span><br><span class="line">            <span class="comment">// 释放缓存</span></span><br><span class="line">            release(key);</span><br><span class="line">            <span class="comment">// 删除引用数据和缓存数据</span></span><br><span class="line">            references.remove(key);</span><br><span class="line">            cache.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现共享内存数组"><a href="#实现共享内存数组" class="headerlink" title="实现共享内存数组"></a>实现共享内存数组</h2><p>​		在 Java 中，当你执行类似 subArray 的操作时，只会在底层进行一个复制，无法同一片内存。 于是，SubArray 类，来（松散地）规定这个数组的可使用范围：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] raw;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubArray</span><span class="params">(<span class="type">byte</span>[] raw, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.raw = raw;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数据页的缓存与管理"><a href="#数据页的缓存与管理" class="headerlink" title="数据页的缓存与管理"></a>数据页的缓存与管理</h1><p>​		DM 直接管理数据库 DB 文件和日志文件。DM 的主要职责有：1) 分页管理 DB 文件，并进行缓存；2) 管理日志文件，保证在发生错误时可以根据日志进行恢复；3) 抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。</p>
<p>​		本节主要内容就是 DM 模块 **向下 **对文件系统的抽象部分。DM 将文件系统抽象成页面，每次对文件系统的读写都是以页面为单位的。同样，从文件系统读进来的数据也是以页面为单位进行缓存的。</p>
<p>读、写、缓存都是以页面为单位进行的。</p>
<h2 id="数据页面缓存的实现"><a href="#数据页面缓存的实现" class="headerlink" title="数据页面缓存的实现"></a>数据页面缓存的实现</h2><h3 id="1、定义页面结构"><a href="#1、定义页面结构" class="headerlink" title="1、定义页面结构"></a>1、定义页面结构</h3><p>​		缓存页面需要先定义页面结构，注意这个页面是存储在内存中的，与已经持久化到磁盘的抽象页面有区别。默认数据页大小定为 8K，缓存页面采用第二节的缓存框架。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageImpl</span> <span class="keyword">implements</span> <span class="title class_">Page</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> pageNumber;<span class="comment">// 页面的页号，从 1 开始</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data;<span class="comment">// 页面包含的实际字节数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> dirty;<span class="comment">// 是否为脏页（缓存驱逐时，脏页需要被写回磁盘）</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// PageCache（还未定义）的引用</span></span><br><span class="line">    <span class="keyword">private</span> PageCache pc;<span class="comment">// 用来方便在拿到 Page 的引用时可以快速对这个页面的缓存进行释放操作。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、定义页面缓存的接口"><a href="#2、定义页面缓存的接口" class="headerlink" title="2、定义页面缓存的接口"></a>2、定义页面缓存的接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PageCache</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PAGE_SIZE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">newPage</span><span class="params">(<span class="type">byte</span>[] initData)</span>;</span><br><span class="line">    Page <span class="title function_">getPage</span><span class="params">(<span class="type">int</span> pgno)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(Page page)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">truncateByBgno</span><span class="params">(<span class="type">int</span> maxPgno)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getPageNumber</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">flushPage</span><span class="params">(Page pg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、页面缓存的具体实现类"><a href="#3、页面缓存的具体实现类" class="headerlink" title="3、页面缓存的具体实现类"></a>3、页面缓存的具体实现类</h3><p>​		需要继承抽象缓存框架，并且实现 getForCache() 和 releaseForCache() 两个抽象方法。由于数据源就是文件系统，getForCache() 直接从文件中读取，并包裹成 Page。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pgno 的前一页末尾，即最后一页的起点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">pageOffset</span><span class="params">(<span class="type">int</span> pgno)</span> &#123;</span><br><span class="line">    <span class="comment">// 页号从 1 开始</span></span><br><span class="line">    <span class="keyword">return</span> (pgno-<span class="number">1</span>) * PAGE_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">根据 pageNumber 从数据库文件中读取页数据，并包裹成Page</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Page <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> (<span class="type">int</span>)key;</span><br><span class="line">    <span class="comment">// pgno 的前一页末尾</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> PageCacheImpl.pageOffset(pgno);</span><br><span class="line">	<span class="comment">// PAGE_SIZE == 8k,创建 8k 空间的缓冲区</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(PAGE_SIZE);</span><br><span class="line">    fileLock.lock();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 定位到 fc 最后一页的起点，并把数据写入 buf</span></span><br><span class="line">        fc.position(offset);</span><br><span class="line">        fc.read(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    fileLock.unlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageImpl</span>(pgno, buf.array(), <span class="built_in">this</span>);<span class="comment">// 根据页号、buf 中数据、页面缓存包装成 Page</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面写回文件系统的方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 pgno,找到该页的起点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> pg.getPageNumber();</span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> pageOffset(pgno);</span><br><span class="line"></span><br><span class="line">    fileLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 把 pg 的数据写入 fc 至系统文件</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(pg.getData());</span><br><span class="line">        fc.position(offset);</span><br><span class="line">        fc.write(buf);</span><br><span class="line">        fc.force(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fileLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱逐页面时，也只需要根据页面是否是脏页面，来决定是否需要写回文件系统：</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">releaseForCache</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(pg.isDirty()) &#123;</span><br><span class="line">        flush(pg);</span><br><span class="line">        pg.setDirty(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、记录数据库文件的页数"><a href="#4、记录数据库文件的页数" class="headerlink" title="4、记录数据库文件的页数"></a>4、记录数据库文件的页数</h3><p>​		PageCache 还使用了一个 AtomicInteger，来记录了当前打开的数据库文件有多少页。这个数字在数据库文件被打开时就会被计算，并在新建页面时自增。</p>
<p>注：同一条数据是不允许跨页存储的，这一点会从后面的章节中体现。这意味着，单条数据的大小不能超过数据库页面的大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">newPage</span><span class="params">(<span class="type">byte</span>[] initData)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> pageNumbers.incrementAndGet();</span><br><span class="line">    <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageImpl</span>(pgno, initData, <span class="literal">null</span>);</span><br><span class="line">    flush(pg);  <span class="comment">// 新建的页面需要立刻写回</span></span><br><span class="line">    <span class="keyword">return</span> pgno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数据页面管理实现"><a href="#数据页面管理实现" class="headerlink" title="数据页面管理实现"></a>数据页面管理实现</h2><h3 id="1、第一页设计"><a href="#1、第一页设计" class="headerlink" title="1、第一页设计"></a>1、第一页设计</h3><p>​		数据库文件的第一页，通常用作一些特殊用途，比如存储一些元数据，用来启动检查什么的。</p>
<p>​		MYDB 的第一页，只是用来做<strong>启动检查</strong>。具体的原理是，在每次数据库启动时，会生成一串随机字节，存储在 100 ~ 107 字节。在数据库正常关闭时，会将这串字节，拷贝到第一页的 108 ~ 115 字节。 这样数据库在每次启动时，就会检查第一页两处的字节是否相同，以此来判断上一次是否正常关闭。如果是异常关闭，就需要执行数据的恢复流程。</p>
<p>1）随机生成字节	2）拷贝字节	3）校验字节0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OF_VC</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">// 存放字符串的起始位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LEN_VC</span> <span class="operator">=</span> <span class="number">8</span>;<span class="comment">// 随机字节长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动时设置初始字节</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcOpen</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    setVcOpen(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcOpen</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    src - 源数组。</span></span><br><span class="line"><span class="comment">	srcPos – 源数组中的起始位置。</span></span><br><span class="line"><span class="comment">	dest - 目标数组。</span></span><br><span class="line"><span class="comment">	destPos – 目标数据中的起始位置。</span></span><br><span class="line"><span class="comment">	length – 被 copy 的数组元素的数量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 被拷贝字符串，0，pg的数据，100开始，结束长度+8,</span></span><br><span class="line">    System.arraycopy(RandomUtil.randomBytes(LEN_VC), <span class="number">0</span>, raw, OF_VC, LEN_VC);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭时拷贝字节</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcClose</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    setVcClose(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVcClose</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="comment">// 字符串，原数组中起始位置100，pg的数据，108开始，结束长度+8,</span></span><br><span class="line">    System.arraycopy(raw, OF_VC, raw, OF_VC+LEN_VC, LEN_VC);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 校验字节</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkVc</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> checkVc(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkVc</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="comment">// 比较 Array 相等</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.equals(Arrays.copyOfRange(raw, OF_VC, OF_VC+LEN_VC), Arrays.copyOfRange(raw, OF_VC+LEN_VC, OF_VC+<span class="number">2</span>*LEN_VC));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 RandomUtil 随机生成数字代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] randomBytes(<span class="type">int</span> length) &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>();</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        r.nextBytes(buf);</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2、普通页设计"><a href="#2、普通页设计" class="headerlink" title="2、普通页设计"></a>2、普通页设计</h3><p>​		一个普通页面以一个 2 字节无符号数起始，表示这一页的空闲位置的偏移。剩下的部分都是实际存储的数据。 所以对普通页的管理，基本都是围绕着对 FSO（Free Space Offset）进行的。</p>
<p>例如向页面插入数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 raw 插入 pg 中，返回插入位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">insert</span><span class="params">(Page pg, <span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">short</span> <span class="variable">offset</span> <span class="operator">=</span> getFSO(pg.getData());</span><br><span class="line">    System.arraycopy(raw, <span class="number">0</span>, pg.getData(), offset, raw.length);</span><br><span class="line">    setFSO(pg.getData(), (<span class="type">short</span>)(offset + raw.length));</span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在写入之前获取 FSO，来确定写入的位置，并在写入之后更新 FSO。FSO 的操作如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFSO</span><span class="params">(<span class="type">byte</span>[] raw, <span class="type">short</span> ofData)</span> &#123;</span><br><span class="line">    System.arraycopy(Parser.short2Byte(ofData), <span class="number">0</span>, raw, OF_FREE, OF_DATA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取pg的FSO</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">getFSO</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getFSO(pg.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">getFSO</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Parser.parseShort(Arrays.copyOfRange(raw, <span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取页面的空闲空间大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getFreeSpace</span><span class="params">(Page pg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PageCache.PAGE_SIZE - (<span class="type">int</span>)getFSO(pg.getData());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩余两个函数 recoverInsert() 和 recoverUpdate() 用于在数据库崩溃后重新打开时，恢复例程直接插入数据以及修改数据使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将raw插入pg中的offset位置，并将pg的offset设置为较大的offset</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recoverInsert</span><span class="params">(Page pg, <span class="type">byte</span>[] raw, <span class="type">short</span> offset)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    System.arraycopy(raw, <span class="number">0</span>, pg.getData(), offset, raw.length);</span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> <span class="variable">rawFSO</span> <span class="operator">=</span> getFSO(pg.getData());</span><br><span class="line">    <span class="keyword">if</span>(rawFSO &lt; offset + raw.length) &#123;</span><br><span class="line">        setFSO(pg.getData(), (<span class="type">short</span>)(offset+raw.length));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将raw插入pg中的offset位置，不更新update</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recoverUpdate</span><span class="params">(Page pg, <span class="type">byte</span>[] raw, <span class="type">short</span> offset)</span> &#123;</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    System.arraycopy(raw, <span class="number">0</span>, pg.getData(), offset, raw.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="日志文件与恢复策略"><a href="#日志文件与恢复策略" class="headerlink" title="日志文件与恢复策略"></a>日志文件与恢复策略</h1><p>​		DM 直接管理数据库 DB 文件和日志文件。DM 的主要职责有：1) 分页管理 DB 文件，并进行缓存；2) 管理日志文件，保证在发生错误时可以根据日志进行恢复；3) 抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。</p>
<p>​		MYDB 提供了崩溃后的数据恢复功能，类似于 MySQL 的 redo log 和 binlog。DM 层在每次对底层数据操作时，都会记录一条日志到磁盘上。在数据库奔溃之后，再次启动时，可以根据日志的内容，恢复数据文件，保证其一致性。 </p>
<h2 id="日志读写实现"><a href="#日志读写实现" class="headerlink" title="日志读写实现"></a>日志读写实现</h2><h3 id="1、日志的格式"><a href="#1、日志的格式" class="headerlink" title="1、日志的格式"></a>1、日志的格式</h3><p>​		日志的二进制文件，按照如下的格式进行排布：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[XChecksum]</span><span class="selector-attr">[Log1]</span><span class="selector-attr">[Log2]</span><span class="selector-attr">[Log3]</span>...<span class="selector-attr">[LogN]</span><span class="selector-attr">[BadTail]</span></span><br></pre></td></tr></table></figure>

<p>​		其中 XChecksum 是一个四字节的整数，是对后续所有日志计算的校验和。Log1 ~ LogN 是常规的日志数据，BadTail 是在数据库崩溃时，没有来得及写完的日志数据，这个 BadTail 不一定存在。</p>
<p>​		 每条日志的格式如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[Size]</span><span class="selector-attr">[Checksum]</span><span class="selector-attr">[Data]</span></span><br></pre></td></tr></table></figure>

<p>​		其中，Size 是一个四字节整数，标识了 Data 段的字节数。Checksum 则是该条日志的校验和。</p>
<h3 id="2、求单条日志的校验和"><a href="#2、求单条日志的校验和" class="headerlink" title="2、求单条日志的校验和"></a>2、求单条日志的校验和</h3><p>​		其实就是通过一个指定的种子实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SEED</span> <span class="operator">=</span> <span class="number">13331</span>;<span class="comment">// 指定种子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对所有日志求出校验和，求和就能得到日志文件的校验和。</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calChecksum</span><span class="params">(<span class="type">int</span> xCheck, <span class="type">byte</span>[] log)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">byte</span> b : log) &#123;</span><br><span class="line">        xCheck = xCheck * SEED + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> xCheck;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、读取日志并返回数据"><a href="#3、读取日志并返回数据" class="headerlink" title="3、读取日志并返回数据"></a>3、读取日志并返回数据</h3><p>​		 Logger 被实现成迭代器模式，通过 next() 方法，不断地从文件中读取下一条日志，并将其中的 Data 解析出来并返回。next() 方法的实现主要依靠 internNext()，大致如下，其中 position 是当前日志文件读到的位置偏移：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OF_SIZE</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OF_CHECKSUM</span> <span class="operator">=</span> OF_SIZE + <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OF_DATA</span> <span class="operator">=</span> OF_CHECKSUM + <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOG_SUFFIX</span> <span class="operator">=</span> <span class="string">&quot;.log&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> RandomAccessFile file;</span><br><span class="line"><span class="keyword">private</span> FileChannel fc;</span><br><span class="line"><span class="keyword">private</span> Lock lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> position;  <span class="comment">// 当前日志指针的位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> fileSize;  <span class="comment">// 初始化时记录，log操作不更新</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> xChecksum;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] next() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 读取下一条日志</span></span><br><span class="line">        <span class="type">byte</span>[] log = internNext();</span><br><span class="line">        <span class="comment">// 解析 Data 并返回数据</span></span><br><span class="line">        <span class="keyword">if</span>(log == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(log, OF_DATA, log.length);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件中读取下一条日志</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] internNext() &#123;</span><br><span class="line">    <span class="comment">// 判断读取位置是都在 fileSize 之内</span></span><br><span class="line">    <span class="keyword">if</span>(position + OF_DATA &gt;= fileSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取size</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">tmp</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    fc.position(position);</span><br><span class="line">    fc.read(tmp);</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> Parser.parseInt(tmp.array());</span><br><span class="line">    <span class="comment">// 判断下一个是不是文件末尾</span></span><br><span class="line">    <span class="keyword">if</span>(position + size + OF_DATA &gt; fileSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取checksum+data</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(OF_DATA + size);</span><br><span class="line">    fc.position(position);</span><br><span class="line">    fc.read(buf);</span><br><span class="line">    <span class="type">byte</span>[] log = buf.array();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验 checksum</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">checkSum1</span> <span class="operator">=</span> calChecksum(<span class="number">0</span>, Arrays.copyOfRange(log, OF_DATA, log.length));</span><br><span class="line">    <span class="type">int</span> <span class="variable">checkSum2</span> <span class="operator">=</span> Parser.parseInt(Arrays.copyOfRange(log, OF_CHECKSUM, OF_DATA));</span><br><span class="line">    <span class="keyword">if</span>(checkSum1 != checkSum2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    position += log.length;</span><br><span class="line">    <span class="keyword">return</span> log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、检验日志文件"><a href="#4、检验日志文件" class="headerlink" title="4、检验日志文件"></a>4、检验日志文件</h3><p>​		在打开一个日志文件时，需要首先校验日志文件的 XChecksum，并移除文件尾部可能存在的 BadTail，由于 BadTail 该条日志尚未写入完成，文件的校验和也就不会包含该日志的校验和，去掉 BadTail 即可保证日志文件的一致性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkAndRemoveTail</span><span class="params">()</span> &#123;</span><br><span class="line">    rewind();</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> <span class="variable">xCheck</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">byte</span>[] log = internNext();</span><br><span class="line">        <span class="keyword">if</span>(log == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">        xCheck = calChecksum(xCheck, log);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(xCheck != xChecksum) &#123;</span><br><span class="line">        Panic.panic(Error.BadLogFileException);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 截断文件到正常日志的末尾</span></span><br><span class="line">    truncate(position);</span><br><span class="line">    rewind();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、向日志文件写入日志"><a href="#5、向日志文件写入日志" class="headerlink" title="5、向日志文件写入日志"></a>5、向日志文件写入日志</h3><p>​		向日志文件写入日志时，也是首先将数据包裹成日志格式，写入文件后，再更新文件的校验和，更新校验和时，会刷新缓冲区，保证内容写入磁盘。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(<span class="type">byte</span>[] data)</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] log = wrapLog(data);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(log);</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fc.position(fc.size());</span><br><span class="line">        fc.write(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    updateXChecksum(log);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateXChecksum</span><span class="params">(<span class="type">byte</span>[] log)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.xChecksum = calChecksum(<span class="built_in">this</span>.xChecksum, log);</span><br><span class="line">    fc.position(<span class="number">0</span>);</span><br><span class="line">    fc.write(ByteBuffer.wrap(Parser.int2Byte(xChecksum)));</span><br><span class="line">    fc.force(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] wrapLog(<span class="type">byte</span>[] data) &#123;</span><br><span class="line">    <span class="type">byte</span>[] checksum = Parser.int2Byte(calChecksum(<span class="number">0</span>, data));</span><br><span class="line">    <span class="type">byte</span>[] size = Parser.int2Byte(data.length);</span><br><span class="line">    <span class="keyword">return</span> Bytes.concat(size, checksum, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h2><p>​		恢复策略来自于 NYADB2 的恢复策略。 DM 为上层模块，提供了两种操作，分别是<strong>插入新数据（I）和更新现有数据（U）</strong>。至于为啥没有删除数据，这个会在 VM 一节叙述。</p>
<p>​		 DM 的日志策略很简单，一句话就是： primary 在进行 I 和 U 操作之前，必须先进行对应的日志操作，在保证日志写入磁盘后，才进行数据操作。这个日志策略，使得 DM 对于数据操作的磁盘同步，可以更加随意。日志在数据操作之前，保证到达了磁盘，那么即使该数据操作最后没有来得及同步到磁盘，数据库就发生了崩溃，后续也可以通过磁盘上的日志恢复该数据。 对于两种数据操作，DM 记录的日志如下：</p>
<p>​		(Ti, I, A, x)，表示事务 Ti 在 A 位置插入了一条数据 x </p>
<p>​		(Ti, U, A, oldx, newx)，表示事务 Ti 将 A 位置的数据，从 oldx 更新成 newx</p>
<p>我们首先不考虑并发的情况，那么在某一时刻，只可能有一个事务在操作数据库。日志会看起来像下面那样：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Ti, x, x), ..., (Ti, x, x), (Tj, x, x), ..., (Tj, x, x), (Tk, x, x), ..., (Tk, x, x)</span><br></pre></td></tr></table></figure>

<h3 id="1、单线程"><a href="#1、单线程" class="headerlink" title="1、单线程"></a>1、单线程</h3><p>​		由于单线程，Ti、Tj 和 Tk 的日志永远不会相交。这种情况下利用	很简单，假设日志中最后一个事务是 Ti：</p>
<p>​		1、对 Ti 之前所有的事务的日志，进行重做（redo）	2、 接着检查 Ti 的状态（XID 文件），如果 Ti 的状态是已完成（包括 committed 和 aborted），就将 Ti 重做，否则进行撤销（undo） </p>
<p>​		接着，是如何对事务 T 进行 redo： </p>
<p>​		1、正序扫描事务 T 的所有日志 	2、如果日志是插入操作 (Ti, I, A, x)，就将 x 重新插入 A 位置 	3、如果日志是更新操作 (Ti, U, A, oldx, newx)，就将 A 位置的值设置为 newx </p>
<p>​		undo 也很好理解：</p>
<p>​		1、倒序扫描事务 T 的所有日志 	2、如果日志是插入操作 (Ti, I, A, x)，就将 A 位置的数据删除	3、 如果日志是更新操作 (Ti, U, A, oldx, newx)，就将 A 位置的值设置为 oldx </p>
<p>​		注意，MYDB 中其实没有真正的删除操作，对于插入操作的 undo，只是将其中的标志位设置为 invalid。对于删除的探讨将在 VM 一节中进行。</p>
<h3 id="2、多线程"><a href="#2、多线程" class="headerlink" title="2、多线程"></a>2、多线程</h3><p>规定1：正在进行的事务，不会读取其他任何未提交的事务产生的数据。</p>
<p>规定2：正在进行的事务，不会修改其他任何未提交的事务修改或产生的数据。</p>
<p>并发情况下日志的恢复：</p>
<p>​		1、重做所有崩溃时已完成（committed 或 aborted）的事务 	2、撤销所有崩溃时未完成（active）的事务</p>
<p>在恢复后，数据库就会恢复到所有已完成事务结束，所有未完成事务尚未开始的状态。</p>
<h2 id="恢复策略的实现"><a href="#恢复策略的实现" class="headerlink" title="恢复策略的实现"></a>恢复策略的实现</h2><h3 id="1、规定日志格式"><a href="#1、规定日志格式" class="headerlink" title="1、规定日志格式"></a>1、规定日志格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">LOG_TYPE_INSERT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">LOG_TYPE_UPDATE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">updateLog:</span><br><span class="line">[LogType] [XID] [UID] [OldRaw] [NewRaw]</span><br><span class="line"></span><br><span class="line">insertLog:</span><br><span class="line">[LogType] [XID] [Pgno] [Offset] [Raw]</span><br></pre></td></tr></table></figure>

<h3 id="2、实现-recover-例程"><a href="#2、实现-recover-例程" class="headerlink" title="2、实现 recover 例程"></a>2、实现 recover 例程</h3><p>​		重做已完成事务， 撤销所有未完成事务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前置方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> InsertLogInfo <span class="title function_">parseInsertLog</span><span class="params">(<span class="type">byte</span>[] log)</span> &#123;</span><br><span class="line">    <span class="type">InsertLogInfo</span> <span class="variable">li</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InsertLogInfo</span>();</span><br><span class="line">    li.xid = Parser.parseLong(Arrays.copyOfRange(log, OF_XID, OF_INSERT_PGNO));</span><br><span class="line">    li.pgno = Parser.parseInt(Arrays.copyOfRange(log, OF_INSERT_PGNO, OF_INSERT_OFFSET));</span><br><span class="line">    li.offset = Parser.parseShort(Arrays.copyOfRange(log, OF_INSERT_OFFSET, OF_INSERT_RAW));</span><br><span class="line">    li.raw = Arrays.copyOfRange(log, OF_INSERT_RAW, log.length);</span><br><span class="line">    <span class="keyword">return</span> li;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> UpdateLogInfo <span class="title function_">parseUpdateLog</span><span class="params">(<span class="type">byte</span>[] log)</span> &#123;</span><br><span class="line">    <span class="type">UpdateLogInfo</span> <span class="variable">li</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateLogInfo</span>();</span><br><span class="line">    li.xid = Parser.parseLong(Arrays.copyOfRange(log, OF_XID, OF_UPDATE_UID));</span><br><span class="line">    <span class="type">long</span> <span class="variable">uid</span> <span class="operator">=</span> Parser.parseLong(Arrays.copyOfRange(log, OF_UPDATE_UID, OF_UPDATE_RAW));</span><br><span class="line">    li.offset = (<span class="type">short</span>)(uid &amp; ((<span class="number">1L</span> &lt;&lt; <span class="number">16</span>) - <span class="number">1</span>));</span><br><span class="line">    uid &gt;&gt;&gt;= <span class="number">32</span>;</span><br><span class="line">    li.pgno = (<span class="type">int</span>)(uid &amp; ((<span class="number">1L</span> &lt;&lt; <span class="number">32</span>) - <span class="number">1</span>));</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> (log.length - OF_UPDATE_RAW) / <span class="number">2</span>;</span><br><span class="line">    li.oldRaw = Arrays.copyOfRange(log, OF_UPDATE_RAW, OF_UPDATE_RAW+length);</span><br><span class="line">    li.newRaw = Arrays.copyOfRange(log, OF_UPDATE_RAW+length, OF_UPDATE_RAW+length*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> li;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doInsertLog</span><span class="params">(PageCache pc, <span class="type">byte</span>[] log, <span class="type">int</span> flag)</span> &#123;</span><br><span class="line">    <span class="type">InsertLogInfo</span> <span class="variable">li</span> <span class="operator">=</span> parseInsertLog(log);</span><br><span class="line">    <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pg = pc.getPage(li.pgno);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag == UNDO) &#123;</span><br><span class="line">            DataItem.setDataItemRawInvalid(li.raw);</span><br><span class="line">        &#125;</span><br><span class="line">        PageX.recoverInsert(pg, li.raw, li.offset);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        pg.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isInsertLog</span><span class="params">(<span class="type">byte</span>[] log)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> log[<span class="number">0</span>] == LOG_TYPE_INSERT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">LOG_TYPE_INSERT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">LOG_TYPE_UPDATE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REDO</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNDO</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InsertLogInfo</span> &#123;</span><br><span class="line">    <span class="type">long</span> xid;</span><br><span class="line">    <span class="type">int</span> pgno;</span><br><span class="line">    <span class="type">short</span> offset;</span><br><span class="line">    <span class="type">byte</span>[] raw;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UpdateLogInfo</span> &#123;</span><br><span class="line">    <span class="type">long</span> xid;</span><br><span class="line">    <span class="type">int</span> pgno;</span><br><span class="line">    <span class="type">short</span> offset;</span><br><span class="line">    <span class="type">byte</span>[] oldRaw;</span><br><span class="line">    <span class="type">byte</span>[] newRaw;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// redo 事务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">redoTranscations</span><span class="params">(TransactionManager tm, Logger lg, PageCache pc)</span> &#123;</span><br><span class="line">    lg.rewind();</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">byte</span>[] log = lg.next();</span><br><span class="line">        <span class="keyword">if</span>(log == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 判断是否为 InsertLog</span></span><br><span class="line">        <span class="keyword">if</span>(isInsertLog(log)) &#123;</span><br><span class="line">            <span class="comment">// InsertLog 转为 InsertLogInfo</span></span><br><span class="line">            <span class="type">InsertLogInfo</span> <span class="variable">li</span> <span class="operator">=</span> parseInsertLog(log);</span><br><span class="line">            <span class="comment">// 取出xid </span></span><br><span class="line">            <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> li.xid;</span><br><span class="line">            <span class="comment">// 判断是否是未完成（active）的事务</span></span><br><span class="line">            <span class="keyword">if</span>(!tm.isActive(xid)) &#123;</span><br><span class="line">                <span class="comment">// 撤销</span></span><br><span class="line">                doInsertLog(pc, log, REDO);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 同理对 UpdateLog 进行处理</span></span><br><span class="line">            <span class="type">UpdateLogInfo</span> <span class="variable">xi</span> <span class="operator">=</span> parseUpdateLog(log);</span><br><span class="line">            <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> xi.xid;</span><br><span class="line">            <span class="keyword">if</span>(!tm.isActive(xid)) &#123;</span><br><span class="line">                doUpdateLog(pc, log, REDO);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// undo 事务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">undoTranscations</span><span class="params">(TransactionManager tm, Logger lg, PageCache pc)</span> &#123;</span><br><span class="line">    Map&lt;Long, List&lt;<span class="type">byte</span>[]&gt;&gt; logCache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    lg.rewind();</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">byte</span>[] log = lg.next();</span><br><span class="line">        <span class="keyword">if</span>(log == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(isInsertLog(log)) &#123;</span><br><span class="line">            <span class="type">InsertLogInfo</span> <span class="variable">li</span> <span class="operator">=</span> parseInsertLog(log);</span><br><span class="line">            <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> li.xid;</span><br><span class="line">            <span class="keyword">if</span>(tm.isActive(xid)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!logCache.containsKey(xid)) &#123;</span><br><span class="line">                    logCache.put(xid, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                logCache.get(xid).add(log);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">UpdateLogInfo</span> <span class="variable">xi</span> <span class="operator">=</span> parseUpdateLog(log);</span><br><span class="line">            <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> xi.xid;</span><br><span class="line">            <span class="keyword">if</span>(tm.isActive(xid)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!logCache.containsKey(xid)) &#123;</span><br><span class="line">                    logCache.put(xid, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                logCache.get(xid).add(log);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对所有active log进行倒序undo</span></span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;Long, List&lt;<span class="type">byte</span>[]&gt;&gt; entry : logCache.entrySet()) &#123;</span><br><span class="line">        List&lt;<span class="type">byte</span>[]&gt; logs = entry.getValue();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> logs.size()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            <span class="type">byte</span>[] log = logs.get(i);</span><br><span class="line">            <span class="keyword">if</span>(isInsertLog(log)) &#123;</span><br><span class="line">                doInsertLog(pc, log, UNDO);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                doUpdateLog(pc, log, UNDO);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tm.abort(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、updateLog-和-insertLog-的重做和撤销处理"><a href="#3、updateLog-和-insertLog-的重做和撤销处理" class="headerlink" title="3、updateLog 和 insertLog 的重做和撤销处理"></a>3、updateLog 和 insertLog 的重做和撤销处理</h3><p>分别合并成一个方法来实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doUpdateLog</span><span class="params">(PageCache pc, <span class="type">byte</span>[] log, <span class="type">int</span> flag)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pgno;</span><br><span class="line">    <span class="type">short</span> offset;</span><br><span class="line">    <span class="type">byte</span>[] raw;</span><br><span class="line">    <span class="keyword">if</span>(flag == REDO) &#123;</span><br><span class="line">        <span class="type">UpdateLogInfo</span> <span class="variable">xi</span> <span class="operator">=</span> parseUpdateLog(log);</span><br><span class="line">        pgno = xi.pgno;</span><br><span class="line">        offset = xi.offset;</span><br><span class="line">        raw = xi.newRaw;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">UpdateLogInfo</span> <span class="variable">xi</span> <span class="operator">=</span> parseUpdateLog(log);</span><br><span class="line">        pgno = xi.pgno;</span><br><span class="line">        offset = xi.offset;</span><br><span class="line">        raw = xi.oldRaw;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pg = pc.getPage(pgno);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        PageX.recoverUpdate(pg, raw, offset);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        pg.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doInsertLog</span><span class="params">(PageCache pc, <span class="type">byte</span>[] log, <span class="type">int</span> flag)</span> &#123;</span><br><span class="line">    <span class="type">InsertLogInfo</span> <span class="variable">li</span> <span class="operator">=</span> parseInsertLog(log);</span><br><span class="line">    <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pg = pc.getPage(li.pgno);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag == UNDO) &#123;</span><br><span class="line">            DataItem.setDataItemRawInvalid(li.raw);</span><br><span class="line">        &#125;</span><br><span class="line">        PageX.recoverInsert(pg, li.raw, li.offset);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        pg.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		注意，doInsertLog() 方法中的删除，使用的是 DataItem.setDataItemRawInvalid(li.raw);，dataItem 将在下一节中说明，大致的作用，就是将该条 DataItem 的有效位设置为无效，来进行逻辑删除。</p>
<h1 id="页面索引和-DM-的实现"><a href="#页面索引和-DM-的实现" class="headerlink" title="页面索引和 DM 的实现"></a>页面索引和 DM 的实现</h1><p>​		DM 直接管理数据库 DB 文件和日志文件。DM 的主要职责有：1) 分页管理 DB 文件，并进行缓存；2) 管理日志文件，保证在发生错误时可以根据日志进行恢复；3) 抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。</p>
<p>​		本节将为 DM 层做收尾，介绍一个实现简单的页面索引。并且实现了 DM 层对于上层的抽象：DataItem。</p>
<h2 id="页面索引实现"><a href="#页面索引实现" class="headerlink" title="页面索引实现"></a>页面索引实现</h2><p>​		页面索引，缓存了每一页的空闲空间。用于在上层模块进行<strong>插入操作时，能够快速找到一个合适空间的页面</strong>，而无需从磁盘或者缓存中检查每一个页面的信息。 </p>
<p>​		MYDB 用一个比较粗略的算法实现了页面索引，将一页的空间划分成了 40 个区间。在启动时，就会遍历所有的页面信息，获取页面的空闲空间，安排到这 40 个区间中。insert 在请求一个页时，会首先将所需的空间向上取整，映射到某一个区间，随后取出这个区间的任何一页，都可以满足需求。 </p>
<h3 id="1、PageIndex-页面索引的实现"><a href="#1、PageIndex-页面索引的实现" class="headerlink" title="1、PageIndex 页面索引的实现"></a>1、PageIndex 页面索引的实现</h3><p>​		通过一个 List 类型的数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageIndex</span> &#123;</span><br><span class="line">    <span class="comment">// 将一页划成40个区间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERVALS_NO</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> PageCache.PAGE_SIZE / INTERVALS_NO;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> List&lt;PageInfo&gt;[] lists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、从-PageIndex-中获取页面"><a href="#2、从-PageIndex-中获取页面" class="headerlink" title="2、从 PageIndex 中获取页面"></a>2、从 PageIndex 中获取页面</h3><p>​		上层用 insert 在请求一个页时，会首先将所需的空间向上取整，算出区间号，直接取区间中的一页即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PageInfo <span class="title function_">select</span><span class="params">(<span class="type">int</span> spaceSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> spaceSize / THRESHOLD;</span><br><span class="line">    <span class="keyword">if</span>(number &lt; INTERVALS_NO) number ++;</span><br><span class="line">    <span class="keyword">while</span>(number &lt;= INTERVALS_NO) &#123;</span><br><span class="line">        <span class="keyword">if</span>(lists[number].size() == <span class="number">0</span>) &#123;</span><br><span class="line">            number ++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[number].remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、页面重新插入-PageIndex-中"><a href="#3、页面重新插入-PageIndex-中" class="headerlink" title="3、页面重新插入 PageIndex 中"></a>3、页面重新插入 PageIndex 中</h3><p>​		返回的 PageInfo 中包含页号和空闲空间大小的信息。 可以注意到，被选择的页，会直接从 PageIndex 中移除，这意味着，同一个页面是不允许并发写的。在上层模块使用完这个页面后，需要将其重新插入 PageIndex：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> pgno, <span class="type">int</span> freeSpace)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> freeSpace / THRESHOLD;</span><br><span class="line">    lists[number].add(<span class="keyword">new</span> <span class="title class_">PageInfo</span>(pgno, freeSpace));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、创建-DM-时所需的工作"><a href="#4、创建-DM-时所需的工作" class="headerlink" title="4、创建 DM 时所需的工作"></a>4、创建 DM 时所需的工作</h3><p>​		在 DataManager 被创建时，需要获取所有页面并填充 PageIndex：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化pageIndex</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">fillPageIndex</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pageNumber</span> <span class="operator">=</span> pc.getPageNumber();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= pageNumber; i ++) &#123;</span><br><span class="line">        <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pg = pc.getPage(i);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line">        pIndex.add(pg.getPageNumber(), PageX.getFreeSpace(pg));</span><br><span class="line">        pg.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意在使用完 Page 后需要及时 release，否则可能会撑爆缓存。 </p>
<h2 id="DataItem-的实现"><a href="#DataItem-的实现" class="headerlink" title="DataItem 的实现"></a>DataItem 的实现</h2><p>​		DataItem 是 DM 层向上层<strong>提供的数据</strong>的抽象。</p>
<p>​		<strong>上层模块获取数据的过程：通过地址，向 DM 请求到对应的 DataItem，再获取到其中的数据。</strong> </p>
<h3 id="1、DataItem-的结构和日志结构"><a href="#1、DataItem-的结构和日志结构" class="headerlink" title="1、DataItem 的结构和日志结构"></a>1、DataItem 的结构和日志结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataItemImpl</span> <span class="keyword">implements</span> <span class="title class_">DataItem</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SubArray raw;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] oldRaw;</span><br><span class="line">    <span class="keyword">private</span> DataManagerImpl dm;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> uid;</span><br><span class="line">    <span class="keyword">private</span> Page pg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		保存一个 dm 的引用是因为其释放依赖 dm 的释放（dm 同时实现了缓存接口，用于缓存 DataItem），以及修改数据时落日志。 DataItem 中保存的数据，结构如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[ValidFlag]</span> <span class="selector-attr">[DataSize]</span> <span class="selector-attr">[Data]</span></span><br></pre></td></tr></table></figure>

<p>​		其中 ValidFlag 占用 1 字节，标识了该 DataItem 是否有效。删除一个 DataItem，只需要简单地将其有效位设置为 0。DataSize 占用 2 字节，标识了后面 Data 的长度。 </p>
<h3 id="2、data-方法获取-DataItem-数据"><a href="#2、data-方法获取-DataItem-数据" class="headerlink" title="2、data();方法获取 DataItem 数据"></a>2、data();方法获取 DataItem 数据</h3><p>​		上层模块在获取到 DataItem 后，可以通过 data() 方法，该方法返回的数组是数据共享的，而不是拷贝实现的，所以使用了 SubArray。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> SubArray <span class="title function_">data</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SubArray</span>(raw.raw, raw.start+OF_DATA, raw.end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、修改-DataItem-的相关-before-unBefore-after-方法"><a href="#3、修改-DataItem-的相关-before-unBefore-after-方法" class="headerlink" title="3、修改 DataItem 的相关 before();unBefore();after() 方法"></a>3、修改 DataItem 的相关 before();unBefore();after() 方法</h3><p>​		在上层模块试图对 DataItem 进行修改时，需要遵循一定的流程：在修改之前需要调用 before() 方法，想要撤销修改时，调用 unBefore() 方法，在修改完成后，调用 after() 方法。整个流程，主要是为了保存前相数据，并及时落日志。DM 会保证对 DataItem 的修改是原子性的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">    wLock.lock();</span><br><span class="line">    pg.setDirty(<span class="literal">true</span>);</span><br><span class="line">    System.arraycopy(raw.raw, raw.start, oldRaw, <span class="number">0</span>, oldRaw.length);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unBefore</span><span class="params">()</span> &#123;</span><br><span class="line">    System.arraycopy(oldRaw, <span class="number">0</span>, raw.raw, raw.start, oldRaw.length);</span><br><span class="line">    wLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    dm.logDataItem(xid, <span class="built_in">this</span>);</span><br><span class="line">    wLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		after() 方法，主要就是调用 dm 中的一个方法，对修改操作落日志，不赘述。 </p>
<h3 id="4、release-方法释放-DataItem-缓存"><a href="#4、release-方法释放-DataItem-缓存" class="headerlink" title="4、release(); 方法释放 DataItem 缓存"></a>4、release(); 方法释放 DataItem 缓存</h3><p>​		在使用完 DataItem 后，也应当及时调用 release() 方法，释放掉 DM 中的 DataItem 的缓存（由 DM 缓存 DataItem）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">    dm.releaseDataItem(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="DM-的实现"><a href="#DM-的实现" class="headerlink" title="DM 的实现"></a>DM 的实现</h2><p>​		DataManager 是 DM 层直接<strong>对外提供方法</strong>的类，实现了对外的几个方法。同时，因为 DataItem 的缓存是存放在 DM 层中的，所以也实现了 DataItem 对象的缓存。</p>
<h3 id="1、解析-DM-的-DataItem-缓存，并获取其中的数据"><a href="#1、解析-DM-的-DataItem-缓存，并获取其中的数据" class="headerlink" title="1、解析 DM 的 DataItem 缓存，并获取其中的数据"></a>1、解析 DM 的 DataItem 缓存，并获取其中的数据</h3><p>​		DataItem 存储的 key，是由页号和页内偏移组成的一个 8 字节无符号整数，页号和偏移各占 4 字节。 DataItem 缓存，getForCache()，只需要从 key 中解析出页号，从 pageCache 中获取到页面，再根据偏移，解析出 DataItem 即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> DataItem <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">short</span> <span class="variable">offset</span> <span class="operator">=</span> (<span class="type">short</span>)(uid &amp; ((<span class="number">1L</span> &lt;&lt; <span class="number">16</span>) - <span class="number">1</span>));</span><br><span class="line">    uid &gt;&gt;&gt;= <span class="number">32</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> (<span class="type">int</span>)(uid &amp; ((<span class="number">1L</span> &lt;&lt; <span class="number">32</span>) - <span class="number">1</span>));</span><br><span class="line">    <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> pc.getPage(pgno);</span><br><span class="line">    <span class="keyword">return</span> DataItem.parseDataItem(pg, offset, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、释放-DM-的-DataItem-缓存，把数据写回数据源"><a href="#2、释放-DM-的-DataItem-缓存，把数据写回数据源" class="headerlink" title="2、释放 DM 的 DataItem 缓存，把数据写回数据源"></a>2、释放 DM 的 DataItem 缓存，把数据写回数据源</h3><p>​		DataItem 缓存释放，需要将 DataItem 写回数据源，由于对文件的读写是以页为单位进行的，只需要将 DataItem 所在的页 release 即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">releaseForCache</span><span class="params">(DataItem di)</span> &#123;</span><br><span class="line">    di.page().release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、创建-DataManager-文件"><a href="#3、创建-DataManager-文件" class="headerlink" title="3、创建 DataManager 文件"></a>3、创建 DataManager 文件</h3><p>​		从已有文件创建 DataManager 和从空文件创建 DataManager 的流程稍有不同，除了 PageCache 和 Logger 的创建方式有所不同以外，从空文件创建首先需要对第一页进行初始化，而从已有文件创建，则是需要对第一页进行校验，来判断是否需要执行恢复流程。并重新对第一页生成随机字节。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DataManager <span class="title function_">create</span><span class="params">(String path, <span class="type">long</span> mem, TransactionManager tm)</span> &#123;</span><br><span class="line">    <span class="type">PageCache</span> <span class="variable">pc</span> <span class="operator">=</span> PageCache.create(path, mem);</span><br><span class="line">    <span class="type">Logger</span> <span class="variable">lg</span> <span class="operator">=</span> Logger.create(path);</span><br><span class="line">    <span class="type">DataManagerImpl</span> <span class="variable">dm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataManagerImpl</span>(pc, lg, tm);</span><br><span class="line">    dm.initPageOne();</span><br><span class="line">    <span class="keyword">return</span> dm;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DataManager <span class="title function_">open</span><span class="params">(String path, <span class="type">long</span> mem, TransactionManager tm)</span> &#123;</span><br><span class="line">    <span class="type">PageCache</span> <span class="variable">pc</span> <span class="operator">=</span> PageCache.open(path, mem);</span><br><span class="line">    <span class="type">Logger</span> <span class="variable">lg</span> <span class="operator">=</span> Logger.open(path);</span><br><span class="line">    <span class="type">DataManagerImpl</span> <span class="variable">dm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataManagerImpl</span>(pc, lg, tm);</span><br><span class="line">    <span class="keyword">if</span>(!dm.loadCheckPageOne()) &#123;</span><br><span class="line">        Recover.recover(tm, lg, pc);</span><br><span class="line">    &#125;</span><br><span class="line">    dm.fillPageIndex();</span><br><span class="line">    PageOne.setVcOpen(dm.pageOne);</span><br><span class="line">    dm.pc.flushPage(dm.pageOne);</span><br><span class="line">    <span class="keyword">return</span> dm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、初始化或检验-DM-文件第一页"><a href="#4、初始化或检验-DM-文件第一页" class="headerlink" title="4、初始化或检验 DM 文件第一页"></a>4、初始化或检验 DM 文件第一页</h3><p>​		由于从空文件创建首先需要对第一页进行初始化，而从已有文件创建，则是需要对第一页进行校验。初始化第一页，和校验第一页，基本都是调用 PageOne 类中的方法实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在创建文件时初始化PageOne</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">initPageOne</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pgno</span> <span class="operator">=</span> pc.newPage(PageOne.InitRaw());</span><br><span class="line">    <span class="keyword">assert</span> pgno == <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pageOne = pc.getPage(pgno);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    pc.flushPage(pageOne);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在打开已有文件时时读入PageOne，并验证正确性</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">loadCheckPageOne</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pageOne = pc.getPage(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PageOne.checkVc(pageOne);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5、read-insert-DM-方法实现-R-和-I"><a href="#5、read-insert-DM-方法实现-R-和-I" class="headerlink" title="5、read();insert(); DM 方法实现 R 和 I"></a>5、read();insert(); DM 方法实现 R 和 I</h3><p>DM 层提供了三个功能供上层使用，分别是读、插入和修改。修改是通过读出的 DataItem 实现的，于是 DataManager 只需要提供 read() 和 insert() 方法。 read() 根据 UID 从缓存中获取 DataItem，并校验有效位：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> DataItem <span class="title function_">read</span><span class="params">(<span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">DataItemImpl</span> <span class="variable">di</span> <span class="operator">=</span> (DataItemImpl)<span class="built_in">super</span>.get(uid);</span><br><span class="line">    <span class="keyword">if</span>(!di.isValid()) &#123;</span><br><span class="line">        di.release();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> di;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		insert() 方法，在 pageIndex 中获取一个足以存储插入内容的页面的页号，获取页面后，首先需要写入插入日志，接着才可以通过 pageX 插入数据，并返回插入位置的偏移。最后需要将页面信息重新插入 pageIndex。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">insert</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">byte</span>[] raw = DataItem.wrapDataItemRaw(data);</span><br><span class="line">    <span class="keyword">if</span>(raw.length &gt; PageX.MAX_FREE_SPACE) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Error.DataTooLargeException;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 尝试获取可用页</span></span><br><span class="line">    <span class="type">PageInfo</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">        pi = pIndex.select(raw.length);</span><br><span class="line">        <span class="keyword">if</span> (pi != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newPgno</span> <span class="operator">=</span> pc.newPage(PageX.initRaw());</span><br><span class="line">            pIndex.add(newPgno, PageX.MAX_FREE_SPACE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pi == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Error.DatabaseBusyException;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">Page</span> <span class="variable">pg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">freeSpace</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pg = pc.getPage(pi.pgno);</span><br><span class="line">        <span class="comment">// 首先做日志</span></span><br><span class="line">        <span class="type">byte</span>[] log = Recover.insertLog(xid, pg, raw);</span><br><span class="line">        logger.log(log);</span><br><span class="line">        <span class="comment">// 再执行插入操作</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">offset</span> <span class="operator">=</span> PageX.insert(pg, raw);</span><br><span class="line"> </span><br><span class="line">        pg.release();</span><br><span class="line">        <span class="keyword">return</span> Types.addressToUid(pi.pgno, offset);</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 将取出的pg重新插入pIndex</span></span><br><span class="line">        <span class="keyword">if</span>(pg != <span class="literal">null</span>) &#123;</span><br><span class="line">            pIndex.add(pi.pgno, PageX.getFreeSpace(pg));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pIndex.add(pi.pgno, freeSpace);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、close-方法，关闭-DM"><a href="#6、close-方法，关闭-DM" class="headerlink" title="6、close();方法，关闭 DM"></a>6、close();方法，关闭 DM</h3><p>​		DataManager 正常关闭时，需要执行缓存和日志的关闭流程，不要忘了设置第一页的字节校验：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.close();</span><br><span class="line">    logger.close();</span><br><span class="line"> </span><br><span class="line">    PageOne.setVcClose(pageOne);</span><br><span class="line">    pageOne.release();</span><br><span class="line">    pc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上，DM 层完结。</p>
<h1 id="记录的版本与事务隔离"><a href="#记录的版本与事务隔离" class="headerlink" title="记录的版本与事务隔离"></a>记录的版本与事务隔离</h1><p>​		从这一章开始，我们开始讨论 Version Manager。VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。</p>
<p>​		类似于 Data Manager 是 MYDB 的数据管理核心，Version Manager 是 MYDB 的事务和数据版本的管理核心。VM 的一个很重要的职责，就是实现了调度序列的可串行化。MYDB 采用两段锁协议（2PL）来实现。当采用 2PL 时，如果某个事务 i 已经对 x 加锁，且另一个事务 j 也想操作 x，但是这个操作与事务 i 之前的操作相互冲突的话，事务 j 就会被阻塞。譬如，T1 已经因为 U1(x) 锁定了 x，那么 T2 对 x 的读或者写操作都会被阻塞，T2 必须等待 T1 释放掉对 x 的锁。</p>
<p>​		<strong>简单来讲就是两个不同事务的 U 操作 或者 两个不同事务的 U、R 操作会造成冲突。所以采用 MVCC 来实现调度序列的可串行化。</strong></p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>​		在介绍 MVCC 之前，首先明确记录和版本的概念。 DM 层向上层提供了数据项（Data Item）的概念，VM 通过管理所有的数据项，向上层提供了记录（Entry）的概念。上层模块通过 VM 操作数据的最小单位，就是记录。VM 则在其内部，为每个记录，维护了多个版本（Version）。每当上层模块对某个记录进行修改时，VM 就会为这个记录创建一个新的版本。 		</p>
<p>​		MYDB 通过 MVCC，降低了事务的阻塞概率。譬如，T1 想要更新记录 X 的值，于是 T1 需要首先获取 X 的锁，接着更新，也就是创建了一个新的 X 的版本，假设为 x3。假设 T1 还没有释放 X 的锁时，T2 想要读取 X 的值，这时候就不会阻塞，MYDB 会返回一个较老版本的 X，例如 x2。这样最后执行的结果，就等价于，T2 先执行，T1 后执行，调度序列依然是可串行化的。如果 X 没有一个更老的版本，那只能等待 T1 释放锁了。所以只是降低了概率。</p>
<p>规定1：正在进行的事务，不会读取其他任何未提交的事务产生的数据。 </p>
<p>规定2：正在进行的事务，不会修改其他任何未提交的事务修改或产生的数据。</p>
<p>由于 2PL 和 MVCC，我们可以看到，这两个条件都被很轻易地满足了。</p>
<h2 id="记录的实现"><a href="#记录的实现" class="headerlink" title="记录的实现"></a>记录的实现</h2><p>​		对于一条记录来说，MYDB 使用 Entry 类维护了其结构。虽然理论上，MVCC 实现了多版本，但是在实现中，VM 并没有提供 Update 操作，对于字段的更新操作由后面的表和字段管理（TBM）实现。所以在 VM 的实现中，一条记录只有一个版本。 </p>
<h3 id="1、存在-Data-Item-中记录"><a href="#1、存在-Data-Item-中记录" class="headerlink" title="1、存在 Data Item 中记录"></a>1、存在 Data Item 中记录</h3><p>一条记录存储在一条 Data Item 中，所以 Entry 中保存一个 DataItem 的引用即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OF_XMIN</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OF_XMAX</span> <span class="operator">=</span> OF_XMIN+<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OF_DATA</span> <span class="operator">=</span> OF_XMAX+<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> uid;</span><br><span class="line">    <span class="keyword">private</span> DataItem dataItem;</span><br><span class="line">    <span class="keyword">private</span> VersionManager vm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Entry <span class="title function_">loadEntry</span><span class="params">(VersionManager vm, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DataItem</span> <span class="variable">di</span> <span class="operator">=</span> ((VersionManagerImpl)vm).dm.read(uid);</span><br><span class="line">        <span class="keyword">return</span> newEntry(vm, di, uid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        dataItem.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、Entry-中存储的数据格式"><a href="#2、Entry-中存储的数据格式" class="headerlink" title="2、Entry 中存储的数据格式"></a>2、Entry 中存储的数据格式</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[XMIN]</span> <span class="selector-attr">[XMAX]</span> <span class="selector-attr">[DATA]</span></span><br></pre></td></tr></table></figure>

<p>​		XMIN 是创建该条记录（版本）的事务编号，而 XMAX 则是删除该条记录（版本）的事务编号。它们的作用将在下一节中说明。DATA 就是这条记录持有的数据。根据这个结构，在创建记录时调用的 wrapEntryRaw() 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] wrapEntryRaw(<span class="type">long</span> xid, <span class="type">byte</span>[] data) &#123;</span><br><span class="line">    <span class="type">byte</span>[] xmin = Parser.long2Byte(xid);</span><br><span class="line">    <span class="type">byte</span>[] xmax = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">return</span> Bytes.concat(xmin, xmax, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、获取记录中的数据"><a href="#3、获取记录中的数据" class="headerlink" title="3、获取记录中的数据"></a>3、获取记录中的数据</h3><p>​		同样，如果要获取记录中持有的数据，也就需要按照这个结构来解析，并且以拷贝的形式返回数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以拷贝的形式返回内容</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] data() &#123;</span><br><span class="line">    dataItem.rLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">SubArray</span> <span class="variable">sa</span> <span class="operator">=</span> dataItem.data();</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[sa.end - sa.start - OF_DATA];</span><br><span class="line">        System.arraycopy(sa.raw, sa.start+OF_DATA, data, <span class="number">0</span>, data.length);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        dataItem.rUnLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、修改返回数据"><a href="#4、修改返回数据" class="headerlink" title="4、修改返回数据"></a>4、修改返回数据</h3><p>​		这里以拷贝的形式返回数据，如果需要修改的话，需要对 DataItem 执行 before() 方法，这个在设置 XMAX 的值中体现了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setXmax</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    dataItem.before();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">SubArray</span> <span class="variable">sa</span> <span class="operator">=</span> dataItem.data();</span><br><span class="line">        System.arraycopy(Parser.long2Byte(xid), <span class="number">0</span>, sa.raw, sa.start+OF_XMAX, <span class="number">8</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        dataItem.after(xid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>before() 和 after() 是在 DataItem 一节中就已经确定的数据项修改规则。</p>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>​		MyDB 支持的事务隔离程度是 RC 为了解决脏读、RR 为了解决不可重复读。</p>
<h3 id="1、读已提交-Read-Committed"><a href="#1、读已提交-Read-Committed" class="headerlink" title="1、读已提交 Read Committed"></a>1、读已提交 Read Committed</h3><p>​		上面提到，如果一个记录的最新版本被加锁，当另一个事务想要修改或读取这条记录时，MYDB 就会返回一个较旧的版本的数据。这时就可以认为，最新的被加锁的版本，对于另一个事务来说，是不可见的。于是版本可见性的概念就诞生了。 版本的可见性与事务的隔离度是相关的。MYDB 支持的最低的事务隔离程度，是“读提交”（Read Committed），即事务在读取数据时, 只能读取已经提交事务产生的数据。保证最低的读提交的好处，第四章中已经说明（防止级联回滚与 commit 语义冲突）。 MYDB 实现读提交，为每个版本维护了两个变量，就是上面提到的 XMIN 和 XMAX</p>
<p>XMIN：创建该版本的事务编号 </p>
<p>XMAX：删除该版本的事务编号</p>
<p>​		XMIN 应当在版本创建时填写，而 XMAX 则在版本被删除，或者有新版本出现时填写。 XMAX 这个变量，也就解释了为什么 DM 层不提供删除操作，当想删除一个版本时，只需要设置其 XMAX，这样，这个版本对每一个 XMAX 之后的事务都是不可见的，也就等价于删除了。 如此，在读提交下，版本对事务的可见性逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(XMIN == Ti and                             <span class="comment">// 由Ti创建且</span></span><br><span class="line">    XMAX == NULL                            <span class="comment">// 还未被删除</span></span><br><span class="line">)</span><br><span class="line">or                                          <span class="comment">// 或</span></span><br><span class="line">(XMIN is commited and                       <span class="comment">// 由一个已提交的事务创建且</span></span><br><span class="line">    (XMAX == NULL or                        <span class="comment">// 尚未删除或</span></span><br><span class="line">    (XMAX != Ti and XMAX is not commited)   <span class="comment">// 由一个未提交的事务删除</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>若条件为 true，则版本对 Ti 可见。那么获取 Ti 适合的版本，只需要从最新版本开始，依次向前检查可见性，如果为 true，就可以直接返回。 以下方法判断某个记录对事务 t 是否可见：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">readCommitted</span><span class="params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> t.xid;</span><br><span class="line">    <span class="type">long</span> <span class="variable">xmin</span> <span class="operator">=</span> e.getXmin();</span><br><span class="line">    <span class="type">long</span> <span class="variable">xmax</span> <span class="operator">=</span> e.getXmax();</span><br><span class="line">    <span class="keyword">if</span>(xmin == xid &amp;&amp; xmax == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(tm.isCommitted(xmin)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(xmax == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(xmax != xid) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!tm.isCommitted(xmax)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 Transaction 结构只提供了一个 XID。 </p>
<h3 id="2、可重复读-Repeatable-Read"><a href="#2、可重复读-Repeatable-Read" class="headerlink" title="2、可重复读  Repeatable Read"></a>2、可重复读  Repeatable Read</h3><p>读提交会导致的问题大家也都很清楚，八股也背了不少。那就是不可重复读和幻读。这里我们来解决不可重复读的问题。 </p>
<p>不可重复度，会导致一个事务在执行期间对同一个数据项的读取得到不同结果。如下面的结果，加入 X 初始值为 0：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T1 begin</span><br><span class="line"><span class="title function_">R1</span><span class="params">(X)</span> <span class="comment">// T1 读得 0</span></span><br><span class="line">T2 begin</span><br><span class="line"><span class="title function_">U2</span><span class="params">(X)</span> <span class="comment">// 将 X 修改为 1</span></span><br><span class="line">T2 commit</span><br><span class="line"><span class="title function_">R1</span><span class="params">(X)</span> <span class="comment">// T1 读的 1</span></span><br></pre></td></tr></table></figure>

<p>可以看到，T1 两次读 X，读到的结果不一样。如果想要避免这个情况，就需要引入更严格的隔离级别，即可重复读（repeatable read）。 T1 在第二次读取的时候，读到了已经提交的 T2 修改的值，导致了这个问题。于是我们可以规定： :::primary 事务只能读取它开始时, 就已经结束的那些事务产生的数据版本 ::: 这条规定，增加于，事务需要忽略：</p>
<p>在本事务后开始的事务的数据; 本事务开始时还是 active 状态的事务的数据</p>
<p>对于第一条，只需要比较事务 ID，即可确定。而对于第二条，则需要在事务 Ti 开始时，记录下当前活跃的所有事务 SP(Ti)，如果记录的某个版本，XMIN 在 SP(Ti) 中，也应当对 Ti 不可见。</p>
<p>于是，可重复读的判断逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(XMIN == Ti and                 <span class="comment">// 由Ti创建且</span></span><br><span class="line"> (XMAX == NULL or               <span class="comment">// 尚未被删除</span></span><br><span class="line">))</span><br><span class="line">or                              <span class="comment">// 或</span></span><br><span class="line">(XMIN is commited and           <span class="comment">// 由一个已提交的事务创建且</span></span><br><span class="line"> XMIN &lt; XID and                 <span class="comment">// 这个事务小于Ti且</span></span><br><span class="line"> XMIN is not in <span class="title function_">SP</span><span class="params">(Ti)</span> and      <span class="comment">// 这个事务在Ti开始前提交且</span></span><br><span class="line"> (XMAX == NULL or               <span class="comment">// 尚未被删除或</span></span><br><span class="line">  (XMAX != Ti and               <span class="comment">// 由其他事务删除但是</span></span><br><span class="line">   (XMAX is not commited or     <span class="comment">// 这个事务尚未提交或</span></span><br><span class="line">XMAX &gt; Ti or                    <span class="comment">// 这个事务在Ti开始之后才开始或</span></span><br><span class="line">XMAX is in <span class="title function_">SP</span><span class="params">(Ti)</span>               <span class="comment">// 这个事务在Ti开始前还未提交</span></span><br><span class="line">))))</span><br></pre></td></tr></table></figure>

<p>于是，需要提供一个结构，来抽象一个事务，以保存快照数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> xid;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> level;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;Long, Boolean&gt; snapshot;</span><br><span class="line">    <span class="keyword">public</span> Exception err;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> autoAborted;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Transaction <span class="title function_">newTransaction</span><span class="params">(<span class="type">long</span> xid, <span class="type">int</span> level, Map&lt;Long, Transaction&gt; active)</span> &#123;</span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transaction</span>();</span><br><span class="line">        t.xid = xid;</span><br><span class="line">        t.level = level;</span><br><span class="line">        <span class="keyword">if</span>(level != <span class="number">0</span>) &#123;</span><br><span class="line">            t.snapshot = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(Long x : active.keySet()) &#123;</span><br><span class="line">                t.snapshot.put(x, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInSnapshot</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(xid == TransactionManagerImpl.SUPER_XID) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> snapshot.containsKey(xid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造方法中的 active，保存着当前所有 active 的事务。于是，可重复读的隔离级别下，一个版本是否对事务可见的判断如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">repeatableRead</span><span class="params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> t.xid;</span><br><span class="line">    <span class="type">long</span> <span class="variable">xmin</span> <span class="operator">=</span> e.getXmin();</span><br><span class="line">    <span class="type">long</span> <span class="variable">xmax</span> <span class="operator">=</span> e.getXmax();</span><br><span class="line">    <span class="keyword">if</span>(xmin == xid &amp;&amp; xmax == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(tm.isCommitted(xmin) &amp;&amp; xmin &lt; xid &amp;&amp; !t.isInSnapshot(xmin)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(xmax == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(xmax != xid) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!tm.isCommitted(xmax) || xmax &gt; xid || t.isInSnapshot(xmax)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="死锁检测与-VM-的实现"><a href="#死锁检测与-VM-的实现" class="headerlink" title="死锁检测与 VM 的实现"></a>死锁检测与 VM 的实现</h1><p>​		VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。上一节已经实现了调度序列的可串行化、 MVCC 和两种隔离级别。</p>
<p>​		本节将收尾 VM 层，介绍一下 MVCC 可能导致的版本跳跃问题，以及 MYDB 如何避免 2PL 导致的死锁，并将其整合为 Version Manager。</p>
<h2 id="版本跳跃问题"><a href="#版本跳跃问题" class="headerlink" title="版本跳跃问题"></a>版本跳跃问题</h2><p>​		说到版本跳跃之前，顺便提一嘴，MVCC 的实现，使得 MYDB 在撤销或是回滚事务很简单：只需要将这个事务标记为 aborted 即可。根据前一章提到的可见性，每个事务都只能看到其他 committed 的事务所产生的数据，一个 aborted 事务产生的数据，就不会对其他事务产生任何影响了，也就相当于，这个事务不曾存在过。 </p>
<h3 id="1、版本跳跃问题举例"><a href="#1、版本跳跃问题举例" class="headerlink" title="1、版本跳跃问题举例"></a>1、版本跳跃问题举例</h3><p>​		版本跳跃问题，考虑如下的情况，假设 X 最初只有 x0 版本，T1 和 T2 都是可重复读的隔离级别：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T1 begin</span><br><span class="line">T2 begin</span><br><span class="line">R1(X) // T1读取x0</span><br><span class="line">R2(X) // T2读取x0</span><br><span class="line">U1(X) // T1将X更新到x1</span><br><span class="line">T1 commit</span><br><span class="line">U2(X) // T2将X更新到x2</span><br><span class="line">T2 commit</span><br></pre></td></tr></table></figure>

<p>​		这种情况实际运行起来是没问题的，但是逻辑上不太正确。T1 将 X 从 x0 更新为了 x1，这是没错的。但是 T2 则是将 X 从 x0 更新成了 x2，跳过了 x1 版本。 </p>
<p>​		读提交是允许版本跳跃的，而可重复读则是不允许版本跳跃的。</p>
<h3 id="2、版本跳跃检查解决"><a href="#2、版本跳跃检查解决" class="headerlink" title="2、版本跳跃检查解决"></a>2、版本跳跃检查解决</h3><p>​		解决版本跳跃的思路也很简单：如果 Ti 需要修改 X，而 X 已经被 Ti 不可见的事务 Tj 修改了，那么要求 Ti 回滚。 上一节中就总结了，Ti 不可见的 Tj，有两种情况：</p>
<ol>
<li>XID(Tj) &gt; XID(Ti)</li>
<li>Tj in SP(Ti)</li>
</ol>
<p>​		于是版本跳跃的检查也就很简单了，取出要修改的数据 X 的最新提交版本，并检查该最新版本的创建者对当前事务是否可见：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isVersionSkip</span><span class="params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">xmax</span> <span class="operator">=</span> e.getXmax();</span><br><span class="line">    <span class="keyword">if</span>(t.level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tm.isCommitted(xmax) &amp;&amp; (xmax &gt; t.xid || t.isInSnapshot(xmax));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><p>​		上一节提到了 2PL 会阻塞事务，直至持有锁的线程释放锁。可以将这种等待关系抽象成有向边，例如 Tj 在等待 Ti，就可以表示为 Tj –&gt; Ti。这样，无数有向边就可以形成一个图（不一定是连通图）。检测死锁也就简单了，只需要查看这个图中是否有环即可。 </p>
<h3 id="1、等待关系抽象为图的图结构"><a href="#1、等待关系抽象为图的图结构" class="headerlink" title="1、等待关系抽象为图的图结构"></a>1、等待关系抽象为图的图结构</h3><p>​		MYDB 使用一个 LockTable 对象，在内存中维护这张图。维护结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, List&lt;Long&gt;&gt; x2u;  <span class="comment">// 某个XID已经获得的资源的UID列表</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Long&gt; u2x;        <span class="comment">// UID被某个XID持有</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, List&lt;Long&gt;&gt; wait; <span class="comment">// 正在等待UID的XID列表</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Lock&gt; waitLock;   <span class="comment">// 正在等待资源的XID的锁</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Long&gt; waitU;      <span class="comment">// XID正在等待的UID</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line"> </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、遇到等待需检测死锁"><a href="#2、遇到等待需检测死锁" class="headerlink" title="2、遇到等待需检测死锁"></a>2、遇到等待需检测死锁</h3><p>​		在每次出现等待的情况时，就尝试向图中增加一条边，并进行死锁检测。如果检测到死锁，就撤销这条边，不允许添加，并撤销该事务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需要等待则返回null，否则返回锁对象</span></span><br><span class="line"><span class="comment">// 会造成死锁则抛出异常</span></span><br><span class="line"><span class="keyword">public</span> Lock <span class="title function_">add</span><span class="params">(<span class="type">long</span> xid, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isInList(x2u, xid, uid)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!u2x.containsKey(uid)) &#123;</span><br><span class="line">            u2x.put(uid, xid);</span><br><span class="line">            putIntoList(x2u, xid, uid);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        waitU.put(xid, uid);</span><br><span class="line">        putIntoList(wait, xid, uid);</span><br><span class="line">        <span class="keyword">if</span>(hasDeadLock()) &#123;</span><br><span class="line">            waitU.remove(xid);</span><br><span class="line">            removeFromList(wait, uid, xid);</span><br><span class="line">            <span class="keyword">throw</span> Error.DeadlockException;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        l.lock();</span><br><span class="line">        waitLock.put(xid, l);</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、继续等待"><a href="#3、继续等待" class="headerlink" title="3、继续等待"></a>3、继续等待</h3><p>​		调用 add，如果需要等待的话，会返回一个上了锁的 Lock 对象。调用方在获取到该对象时，需要尝试获取该对象的锁，由此实现阻塞线程的目的，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">l</span> <span class="operator">=</span> lt.add(xid, uid);</span><br><span class="line"><span class="keyword">if</span>(l != <span class="literal">null</span>) &#123;</span><br><span class="line">    l.lock();   <span class="comment">// 阻塞在这一步</span></span><br><span class="line">    l.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、通过查看图中是否有环来检测死锁"><a href="#4、通过查看图中是否有环来检测死锁" class="headerlink" title="4、通过查看图中是否有环来检测死锁"></a>4、通过查看图中是否有环来检测死锁</h3><p>​		多个等待关系可以抽象为有环的图，查找图中是否有环，采用深搜，只是需要注意这个图不一定是连通图。思路就是为每个节点设置一个访问戳，都初始化为 -1，随后遍历所有节点，以每个非 -1 的节点作为根进行深搜，并将深搜该连通图中遇到的所有节点都设置为同一个数字，不同的连通图数字不同。这样，如果在遍历某个图时，遇到了之前遍历过的节点，说明出现了环。 实现很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasDeadLock</span><span class="params">()</span> &#123;</span><br><span class="line">    xidStamp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    stamp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> xid : x2u.keySet()) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">s</span> <span class="operator">=</span> xidStamp.get(xid);</span><br><span class="line">        <span class="keyword">if</span>(s != <span class="literal">null</span> &amp;&amp; s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stamp ++;</span><br><span class="line">        <span class="keyword">if</span>(dfs(xid)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">stp</span> <span class="operator">=</span> xidStamp.get(xid);</span><br><span class="line">    <span class="keyword">if</span>(stp != <span class="literal">null</span> &amp;&amp; stp == stamp) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stp != <span class="literal">null</span> &amp;&amp; stp &lt; stamp) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    xidStamp.put(xid, stamp);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Long</span> <span class="variable">uid</span> <span class="operator">=</span> waitU.get(xid);</span><br><span class="line">    <span class="keyword">if</span>(uid == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">x</span> <span class="operator">=</span> u2x.get(uid);</span><br><span class="line">    <span class="keyword">assert</span> x != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> dfs(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、释放锁的方法"><a href="#5、释放锁的方法" class="headerlink" title="5、释放锁的方法"></a>5、释放锁的方法</h3><p>​		在一个事务 commit 或者 abort 时，就可以释放所有它持有的锁，并将自身从等待图中删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">long</span> xid)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;Long&gt; l = x2u.get(xid);</span><br><span class="line">        <span class="keyword">if</span>(l != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(l.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">Long</span> <span class="variable">uid</span> <span class="operator">=</span> l.remove(<span class="number">0</span>);</span><br><span class="line">                selectNewXID(uid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        waitU.remove(xid);</span><br><span class="line">        x2u.remove(xid);</span><br><span class="line">        waitLock.remove(xid);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		while 循环释放掉了这个线程所有持有的资源的锁，这些资源可以被等待的线程所获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从等待队列中选择一个xid来占用uid</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">selectNewXID</span><span class="params">(<span class="type">long</span> uid)</span> &#123;</span><br><span class="line">    u2x.remove(uid);</span><br><span class="line">    List&lt;Long&gt; l = wait.get(uid);</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">assert</span> l.size() &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> l.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!waitLock.containsKey(xid)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            u2x.put(uid, xid);</span><br><span class="line">            <span class="type">Lock</span> <span class="variable">lo</span> <span class="operator">=</span> waitLock.remove(xid);</span><br><span class="line">            waitU.remove(xid);</span><br><span class="line">            lo.unlock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l.size() == <span class="number">0</span>) wait.remove(uid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		从 List 开头开始尝试解锁，还是个公平锁。解锁时，将该 Lock 对象 unlock 即可，这样业务线程就获取到了锁，就可以继续执行了。 </p>
<h2 id="VM-的整合实现"><a href="#VM-的整合实现" class="headerlink" title="VM 的整合实现"></a>VM 的整合实现</h2><h3 id="1、VM-接口参数和基本方法的实现"><a href="#1、VM-接口参数和基本方法的实现" class="headerlink" title="1、VM 接口参数和基本方法的实现"></a>1、VM 接口参数和基本方法的实现</h3><p>​		 VM 层通过 Version Manager 接口，向上层提供功能，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VersionManager</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] read(<span class="type">long</span> xid, <span class="type">long</span> uid) <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">insert</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="type">long</span> xid, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"> </span><br><span class="line">    <span class="type">long</span> <span class="title function_">begin</span><span class="params">(<span class="type">int</span> level)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">long</span> xid)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取缓存</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Entry <span class="title function_">getForCache</span><span class="params">(<span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> Entry.loadEntry(<span class="built_in">this</span>, uid);</span><br><span class="line">    <span class="keyword">if</span>(entry == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Error.NullEntryException;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放缓存</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">releaseForCache</span><span class="params">(Entry entry)</span> &#123;</span><br><span class="line">    entry.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		同时，VM 的实现类还被设计为 Entry 的缓存，需要继承 AbstractCache。需要实现的获取到缓存和从缓存释放的方法。</p>
<h3 id="2、begin-commit-internAbort-方法对事务进行操作"><a href="#2、begin-commit-internAbort-方法对事务进行操作" class="headerlink" title="2、begin();commit();internAbort();方法对事务进行操作"></a>2、begin();commit();internAbort();方法对事务进行操作</h3><p>​		begin() 开启一个事务，并初始化事务的结构，将其存放在 activeTransaction 中，用于检查和快照使用。</p>
<p>​		commit() 方法提交一个事务，主要就是 free 掉相关的结构，并且释放持有的锁，并修改 TM 状态。</p>
<p>​		abort 事务的方法则有两种，手动和自动。手动指的是调用 abort() 方法，而自动，则是在事务被检测出出现死锁时，会自动撤销回滚事务；或者出现版本跳跃时，也会自动回滚。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启事务</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">begin</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">xid</span> <span class="operator">=</span> tm.begin();</span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> Transaction.newTransaction(xid, level, activeTransaction);</span><br><span class="line">        activeTransaction.put(xid, t);</span><br><span class="line">        <span class="keyword">return</span> xid;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid);</span><br><span class="line">    lock.unlock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(t.err != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> t.err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(NullPointerException n) &#123;</span><br><span class="line">        System.out.println(xid);</span><br><span class="line">        System.out.println(activeTransaction.keySet());</span><br><span class="line">        Panic.panic(n);</span><br><span class="line">    &#125;</span><br><span class="line">    lock.lock();</span><br><span class="line">    activeTransaction.remove(xid);</span><br><span class="line">    lock.unlock();</span><br><span class="line">    lt.remove(xid);</span><br><span class="line">    tm.commit(xid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取消事务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">internAbort</span><span class="params">(<span class="type">long</span> xid, <span class="type">boolean</span> autoAborted)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid);</span><br><span class="line">    <span class="keyword">if</span>(!autoAborted) &#123;</span><br><span class="line">        activeTransaction.remove(xid);</span><br><span class="line">    &#125;</span><br><span class="line">    lock.unlock();</span><br><span class="line">    <span class="keyword">if</span>(t.autoAborted) <span class="keyword">return</span>;</span><br><span class="line">    lt.remove(xid);</span><br><span class="line">    tm.abort(xid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、red-insert-delete-方法对数据进行操作"><a href="#3、red-insert-delete-方法对数据进行操作" class="headerlink" title="3、red();insert();delete(); 方法对数据进行操作"></a>3、red();insert();delete(); 方法对数据进行操作</h3><p>​		read() 方法读取一个 entry，注意判断下可见性即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] read(<span class="type">long</span> xid, <span class="type">long</span> uid) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid);</span><br><span class="line">    lock.unlock();</span><br><span class="line">    <span class="keyword">if</span>(t.err != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> t.err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="built_in">super</span>.get(uid);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(Visibility.isVisible(tm, t, entry)) &#123;</span><br><span class="line">            <span class="keyword">return</span> entry.data();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        entry.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		insert() 则是将数据包裹成 Entry，无脑交给 DM 插入即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">insert</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid);</span><br><span class="line">    lock.unlock();</span><br><span class="line">    <span class="keyword">if</span>(t.err != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> t.err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">byte</span>[] raw = Entry.wrapEntryRaw(xid, data);</span><br><span class="line">    <span class="keyword">return</span> dm.insert(xid, raw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		delete();方法看起来略为复杂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="type">long</span> xid, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">t</span> <span class="operator">=</span> activeTransaction.get(xid);</span><br><span class="line">    lock.unlock();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(t.err != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> t.err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="built_in">super</span>.get(uid);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!Visibility.isVisible(tm, t, entry)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">l</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            l = lt.add(xid, uid);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            t.err = Error.ConcurrentUpdateException;</span><br><span class="line">            internAbort(xid, <span class="literal">true</span>);</span><br><span class="line">            t.autoAborted = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">throw</span> t.err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l != <span class="literal">null</span>) &#123;</span><br><span class="line">            l.lock();</span><br><span class="line">            l.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(entry.getXmax() == xid) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Visibility.isVersionSkip(tm, t, entry)) &#123;</span><br><span class="line">            t.err = Error.ConcurrentUpdateException;</span><br><span class="line">            internAbort(xid, <span class="literal">true</span>);</span><br><span class="line">            t.autoAborted = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">throw</span> t.err;</span><br><span class="line">        &#125;</span><br><span class="line">        entry.setXmax(xid);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        entry.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上主要是前置的三件事：一是可见性判断，二是获取资源的锁，三是版本跳跃判断。删除的操作只有一个设置 XMAX。</p>
<h1 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h1><p>​		IM，即 Index Manager，索引管理器，为 MYDB 提供了基于 B+ 树的聚簇索引。目前 MYDB 只支持基于索引查找数据，不支持全表扫描。感兴趣的同学可以自行实现。 在依赖关系图中可以看到，IM 直接基于 DM，而没有基于 VM。索引的数据被直接插入数据库文件中，而不需要经过版本管理。 本节不赘述 B+ 树算法，更多描述实现。</p>
<h2 id="二叉树索引"><a href="#二叉树索引" class="headerlink" title="二叉树索引"></a>二叉树索引</h2><h3 id="1、二叉树结构"><a href="#1、二叉树结构" class="headerlink" title="1、二叉树结构"></a>1、二叉树结构</h3><p>​		二叉树由一个个 Node 组成，每个 Node 都存储在一条 DataItem 中。结构如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[LeafFlag]</span><span class="selector-attr">[KeyNumber]</span><span class="selector-attr">[SiblingUid]</span></span><br><span class="line"><span class="selector-attr">[Son0]</span><span class="selector-attr">[Key0]</span><span class="selector-attr">[Son1]</span><span class="selector-attr">[Key1]</span>...<span class="selector-attr">[SonN]</span><span class="selector-attr">[KeyN]</span></span><br></pre></td></tr></table></figure>

<p>​		其中 LeafFlag 标记了该节点是否是个叶子节点；KeyNumber 为该节点中 key 的个数；SiblingUid 是其兄弟节点存储在 DM 中的 UID。后续是穿插的子节点（SonN）和 KeyN。最后的一个 KeyN 始终为 MAX_VALUE，以此方便查找。 Node 类持有了其 B+ 树结构的引用，DataItem 的引用和 SubArray 的引用，用于方便快速修改数据和释放数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    BPlusTree tree;</span><br><span class="line">    DataItem dataItem;</span><br><span class="line">    SubArray raw;</span><br><span class="line">    <span class="type">long</span> uid;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、根节点的结构"><a href="#2、根节点的结构" class="headerlink" title="2、根节点的结构"></a>2、根节点的结构</h3><p>​		于是生成一个根节点的数据可以写成如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] newRootRaw(<span class="type">long</span> left, <span class="type">long</span> right, <span class="type">long</span> key)  &#123;</span><br><span class="line">    <span class="type">SubArray</span> <span class="variable">raw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubArray</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[NODE_SIZE], <span class="number">0</span>, NODE_SIZE);</span><br><span class="line">    setRawIsLeaf(raw, <span class="literal">false</span>);</span><br><span class="line">    setRawNoKeys(raw, <span class="number">2</span>);</span><br><span class="line">    setRawSibling(raw, <span class="number">0</span>);</span><br><span class="line">    setRawKthSon(raw, left, <span class="number">0</span>);</span><br><span class="line">    setRawKthKey(raw, key, <span class="number">0</span>);</span><br><span class="line">    setRawKthSon(raw, right, <span class="number">1</span>);</span><br><span class="line">    setRawKthKey(raw, Long.MAX_VALUE, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> raw.raw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		该根节点的初始两个子节点为 left 和 right, 初始键值为 key。 类似的，生成一个空的根节点数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] newNilRootRaw()  &#123;</span><br><span class="line">    <span class="type">SubArray</span> <span class="variable">raw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubArray</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[NODE_SIZE], <span class="number">0</span>, NODE_SIZE);</span><br><span class="line">    setRawIsLeaf(raw, <span class="literal">true</span>);</span><br><span class="line">    setRawNoKeys(raw, <span class="number">0</span>);</span><br><span class="line">    setRawSibling(raw, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> raw.raw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、searchNex-leafSearchRange-方法用于辅助-B-树做插入和搜索操作"><a href="#3、searchNex-leafSearchRange-方法用于辅助-B-树做插入和搜索操作" class="headerlink" title="3、searchNex(); leafSearchRange(); 方法用于辅助 B+ 树做插入和搜索操作"></a>3、searchNex(); leafSearchRange(); 方法用于辅助 B+ 树做插入和搜索操作</h3><p>​		Node 类有两个方法，用于辅助 B+ 树做插入和搜索操作，分别是 searchNext 方法和 leafSearchRange 方法。 searchNext 寻找对应 key 的 UID, 如果找不到, 则返回兄弟节点的 UID。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SearchNextRes <span class="title function_">searchNext</span><span class="params">(<span class="type">long</span> key)</span> &#123;</span><br><span class="line">    dataItem.rLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">SearchNextRes</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchNextRes</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">noKeys</span> <span class="operator">=</span> getRawNoKeys(raw);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; noKeys; i ++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ik</span> <span class="operator">=</span> getRawKthKey(raw, i);</span><br><span class="line">            <span class="keyword">if</span>(key &lt; ik) &#123;</span><br><span class="line">                res.uid = getRawKthSon(raw, i);</span><br><span class="line">                res.siblingUid = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.uid = <span class="number">0</span>;</span><br><span class="line">        res.siblingUid = getRawSibling(raw);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        dataItem.rUnLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		leafSearchRange 方法在当前节点进行范围查找，范围是 [leftKey, rightKey]，这里约定如果 rightKey 大于等于该节点的最大的 key, 则还同时返回兄弟节点的 UID，方便继续搜索下一个节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> LeafSearchRangeRes <span class="title function_">leafSearchRange</span><span class="params">(<span class="type">long</span> leftKey, <span class="type">long</span> rightKey)</span> &#123;</span><br><span class="line">    dataItem.rLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">noKeys</span> <span class="operator">=</span> getRawNoKeys(raw);</span><br><span class="line">        <span class="type">int</span> <span class="variable">kth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(kth &lt; noKeys) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ik</span> <span class="operator">=</span> getRawKthKey(raw, kth);</span><br><span class="line">            <span class="keyword">if</span>(ik &gt;= leftKey) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            kth ++;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Long&gt; uids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(kth &lt; noKeys) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ik</span> <span class="operator">=</span> getRawKthKey(raw, kth);</span><br><span class="line">            <span class="keyword">if</span>(ik &lt;= rightKey) &#123;</span><br><span class="line">                uids.add(getRawKthSon(raw, kth));</span><br><span class="line">                kth ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">siblingUid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(kth == noKeys) &#123;</span><br><span class="line">            siblingUid = getRawSibling(raw);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LeafSearchRangeRes</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeafSearchRangeRes</span>();</span><br><span class="line">        res.uids = uids;</span><br><span class="line">        res.siblingUid = siblingUid;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        dataItem.rUnLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、设置-bootDataItem-适应根节点的调整"><a href="#4、设置-bootDataItem-适应根节点的调整" class="headerlink" title="4、设置 bootDataItem 适应根节点的调整"></a>4、设置 bootDataItem 适应根节点的调整</h3><p>由于 B+ 树在插入删除时，会动态调整，根节点不是固定节点，于是设置一个 bootDataItem，该 DataItem 中存储了根节点的 UID。可以注意到，IM 在操作 DM 时，使用的事务都是 SUPER_XID。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BPlusTree</span> &#123;</span><br><span class="line">    DataItem bootDataItem;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">rootUid</span><span class="params">()</span> &#123;</span><br><span class="line">        bootLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SubArray</span> <span class="variable">sa</span> <span class="operator">=</span> bootDataItem.data();</span><br><span class="line">            <span class="keyword">return</span> Parser.parseLong(Arrays.copyOfRange(sa.raw, sa.start, sa.start+<span class="number">8</span>));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bootLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateRootUid</span><span class="params">(<span class="type">long</span> left, <span class="type">long</span> right, <span class="type">long</span> rightKey)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        bootLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] rootRaw = Node.newRootRaw(left, right, rightKey);</span><br><span class="line">            <span class="type">long</span> <span class="variable">newRootUid</span> <span class="operator">=</span> dm.insert(TransactionManagerImpl.SUPER_XID, rootRaw);</span><br><span class="line">            bootDataItem.before();</span><br><span class="line">            <span class="type">SubArray</span> <span class="variable">diRaw</span> <span class="operator">=</span> bootDataItem.data();</span><br><span class="line">            System.arraycopy(Parser.long2Byte(newRootUid), <span class="number">0</span>, diRaw.raw, diRaw.start, <span class="number">8</span>);</span><br><span class="line">            bootDataItem.after(TransactionManagerImpl.SUPER_XID);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bootLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IM 对上层模块主要提供两种能力：插入索引和搜索节点。向 B+ 树插入节点和搜索节点的算法和实现，不再赘述。 这里可能会有疑问，IM 为什么不提供删除索引的能力。当上层模块通过 VM 删除某个 Entry，实际的操作是设置其 XMAX。如果不去删除对应索引的话，当后续再次尝试读取该 Entry 时，是可以通过索引寻找到的，但是由于设置了 XMAX，寻找不到合适的版本而返回一个找不到内容的错误。</p>
<h2 id="可能的错误与恢复"><a href="#可能的错误与恢复" class="headerlink" title="可能的错误与恢复"></a>可能的错误与恢复</h2><p>​		B+ 树在操作过程中，可能出现两种错误，分别是节点内部错误和节点间关系错误。 当节点内部错误发生时，即当 Ti 在对节点的数据进行更改时，MYDB 发生了崩溃。由于 IM 依赖于 DM，在数据库重启后，Ti 会被撤销（undo），对节点的错误影响会被消除。 如果出现了节点间错误，那么一定是下面这种情况：某次对 u 节点的插入操作创建了新节点 v, 此时 sibling(u)&#x3D;v，但是 v 却并没有被插入到父节点中。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[parent]</span></span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line">   <span class="selector-attr">[u]</span> -&gt; <span class="selector-attr">[v]</span></span><br></pre></td></tr></table></figure>

<p>​		正确的状态应当如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[ parent ]</span></span><br><span class="line"> |      |</span><br><span class="line"> v      v</span><br><span class="line"><span class="selector-attr">[u]</span> -&gt; <span class="selector-attr">[v]</span></span><br></pre></td></tr></table></figure>

<p>​		这时，如果要对节点进行插入或者搜索操作，如果失败，就会继续迭代它的兄弟节点，最终还是可以找到 v 节点。唯一的缺点仅仅是，无法直接通过父节点找到 v 了，只能间接地通过 u 获取到 v。</p>
<p>字段与表管理</p>
<p>​		本章概述 TBM，即表<strong>管理器</strong>的实现。TBM 实现了对字段结构和表结构的管理。同时简要介绍 MYDB 使用的类 SQL 语句的解析。</p>
<p>SQL 解析器</p>
<p>​		<strong>Parser 实现</strong>了对类 <strong>SQL 语句的结构化解析</strong>，将语句中包含的信息封装为对应语句的类，这些类可见 top.guoziyang.mydb.backend.parser.statement 包。</p>
<p>​		MYDB 实现的 SQL 语句语法如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;begin statement&gt;</span><br><span class="line">    begin <span class="selector-attr">[isolation level (read committed|repeatable read)]</span></span><br><span class="line">        begin <span class="attribute">isolation</span> level read committed</span><br><span class="line"> </span><br><span class="line">&lt;commit statement&gt;</span><br><span class="line">    commit</span><br><span class="line"> </span><br><span class="line">&lt;abort statement&gt;</span><br><span class="line">    abort</span><br><span class="line"> </span><br><span class="line">&lt;create statement&gt;</span><br><span class="line">    create <span class="selector-tag">table</span> &lt;<span class="selector-tag">table</span> name&gt;</span><br><span class="line">    &lt;field name&gt; &lt;field type&gt;</span><br><span class="line">    &lt;field name&gt; &lt;field type&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;field name&gt; &lt;field type&gt;</span><br><span class="line">    <span class="selector-attr">[(index &lt;field name list&gt;)]</span></span><br><span class="line">        create <span class="selector-tag">table</span> students</span><br><span class="line">        id int32,</span><br><span class="line">        name string,</span><br><span class="line">        age int32,</span><br><span class="line">        (index id name)</span><br><span class="line"> </span><br><span class="line">&lt;drop statement&gt;</span><br><span class="line">    drop <span class="selector-tag">table</span> &lt;<span class="selector-tag">table</span> name&gt;</span><br><span class="line">        drop <span class="selector-tag">table</span> students</span><br><span class="line"> </span><br><span class="line">&lt;select statement&gt;</span><br><span class="line">    select (*|&lt;field name list&gt;) <span class="selector-tag">from</span> &lt;<span class="selector-tag">table</span> name&gt; <span class="selector-attr">[&lt;where statement&gt;]</span></span><br><span class="line">        select * <span class="selector-tag">from</span> student where id = <span class="number">1</span></span><br><span class="line">        select name <span class="selector-tag">from</span> student where id &gt; <span class="number">1</span> and id &lt; <span class="number">4</span></span><br><span class="line">        select name, age, id <span class="selector-tag">from</span> student where id = <span class="number">12</span></span><br><span class="line"> </span><br><span class="line">&lt;insert statement&gt;</span><br><span class="line">    insert into &lt;<span class="selector-tag">table</span> name&gt; values &lt;value list&gt;</span><br><span class="line">        insert into student values <span class="number">5</span> &quot;Zhang Yuanjia&quot; <span class="number">22</span></span><br><span class="line"> </span><br><span class="line">&lt;delete statement&gt;</span><br><span class="line">    delete <span class="selector-tag">from</span> &lt;<span class="selector-tag">table</span> name&gt; &lt;where statement&gt;</span><br><span class="line">        delete <span class="selector-tag">from</span> student where name = &quot;Zhang Yuanjia&quot;</span><br><span class="line"> </span><br><span class="line">&lt;update statement&gt;</span><br><span class="line">    update &lt;<span class="selector-tag">table</span> name&gt; set &lt;field name&gt;=&lt;value&gt; <span class="selector-attr">[&lt;where statement&gt;]</span></span><br><span class="line">        update student set name = &quot;ZYJ&quot; where id = <span class="number">5</span></span><br><span class="line"> </span><br><span class="line">&lt;where statement&gt;</span><br><span class="line">    where &lt;field name&gt; (&gt;|&lt;|=) &lt;value&gt; <span class="selector-attr">[(and|or) &lt;field name&gt; (&gt;|&lt;|=) &lt;value&gt;]</span></span><br><span class="line">        where age &gt; <span class="number">10</span> or age &lt; <span class="number">3</span></span><br><span class="line"> </span><br><span class="line">&lt;field name&gt; &lt;<span class="selector-tag">table</span> name&gt;</span><br><span class="line">    <span class="selector-attr">[a-zA-Z]</span><span class="selector-attr">[a-zA-Z0-9_]</span>*</span><br><span class="line"> </span><br><span class="line">&lt;field type&gt;</span><br><span class="line">    int32 int64 string</span><br><span class="line"> </span><br><span class="line">&lt;value&gt;</span><br><span class="line">    .*</span><br></pre></td></tr></table></figure>

<p>​		parser 包的 Tokenizer 类，对语句进行逐字节解析，根据空白符或者上述词法规则，将语句切割成多个 token。对外提供了 peek()、pop() 方法方便取出 Token 进行解析。切割的实现不赘述。 Parser 类则直接对外提供了 Parse(byte[] statement) 方法，核心就是一个调用 Tokenizer 类分割 Token，并根据词法规则包装成具体的 Statement 类并返回。解析过程很简单，仅仅是根据第一个 Token 来区分语句类型，并分别处理，不再赘述。 虽然根据编译原理，词法分析应当写一个自动机去做的，但是又不是不能用。</p>
<h2 id="字段与表管理"><a href="#字段与表管理" class="headerlink" title="字段与表管理"></a>字段与表管理</h2><p>​		注意，这里的字段与表管理，不是管理各个条目中不同的字段的数值等信息，而是<strong>管理表和字段的结构数据</strong>，例如表名、表字段信息和字段索引等。 </p>
<h4 id="1、单个字段信息和表信息的储存结构"><a href="#1、单个字段信息和表信息的储存结构" class="headerlink" title="1、单个字段信息和表信息的储存结构"></a>1、单个字段信息和表信息的储存结构</h4><p>​		由于 TBM 基于 VM，单个字段信息和表信息都是直接保存在 Entry 中。字段的二进制表示如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[FieldName]</span><span class="selector-attr">[TypeName]</span><span class="selector-attr">[IndexUid]</span></span><br></pre></td></tr></table></figure>

<p>​		这里 FieldName 和 TypeName，以及后面的表明，存储的都是字节形式的字符串。</p>
<p>​		这里规定一个字符串的存储方式，以明确其存储边界。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[StringLength]</span><span class="selector-attr">[StringData]</span></span><br></pre></td></tr></table></figure>

<p>​		TypeName 为字段的类型，限定为 int32、int64 和 string 类型。如果这个字段有索引，那个 IndexUID 指向了索引二叉树的根，否则该字段为 0。</p>
<h4 id="2、根据-UID-读取并解析单个字段和表信息"><a href="#2、根据-UID-读取并解析单个字段和表信息" class="headerlink" title="2、根据 UID 读取并解析单个字段和表信息"></a>2、根据 UID 读取并解析单个字段和表信息</h4><p>​		根据这个结构，通过一个 UID 从 VM 中读取并解析如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title function_">loadField</span><span class="params">(Table tb, <span class="type">long</span> uid)</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] raw = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        raw = ((TableManagerImpl)tb.tbm).vm.read(TransactionManagerImpl.SUPER_XID, uid);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span> raw != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Field</span>(uid, tb).parseSelf(raw);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> Field <span class="title function_">parseSelf</span><span class="params">(<span class="type">byte</span>[] raw)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">ParseStringRes</span> <span class="variable">res</span> <span class="operator">=</span> Parser.parseString(raw);</span><br><span class="line">    fieldName = res.str;</span><br><span class="line">    position += res.next;</span><br><span class="line">    res = Parser.parseString(Arrays.copyOfRange(raw, position, raw.length));</span><br><span class="line">    fieldType = res.str;</span><br><span class="line">    position += res.next;</span><br><span class="line">    <span class="built_in">this</span>.index = Parser.parseLong(Arrays.copyOfRange(raw, position, position+<span class="number">8</span>));</span><br><span class="line">    <span class="keyword">if</span>(index != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bt = BPlusTree.load(index, ((TableManagerImpl)tb.tbm).dm);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            Panic.panic(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、持久化信息"><a href="#3、持久化信息" class="headerlink" title="3、持久化信息"></a>3、持久化信息</h4><p>​		创建一个字段的方法类似，将相关的信息通过 VM 持久化即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">persistSelf</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">byte</span>[] nameRaw = Parser.string2Byte(fieldName);</span><br><span class="line">    <span class="type">byte</span>[] typeRaw = Parser.string2Byte(fieldType);</span><br><span class="line">    <span class="type">byte</span>[] indexRaw = Parser.long2Byte(index);</span><br><span class="line">    <span class="built_in">this</span>.uid = ((TableManagerImpl)tb.tbm).vm.insert(xid, Bytes.concat(nameRaw, typeRaw, indexRaw));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、链表管理管理多张表"><a href="#4、链表管理管理多张表" class="headerlink" title="4、链表管理管理多张表"></a>4、链表管理管理多张表</h4><p>​		一个数据库中存在多张表，TBM 使用链表的形式将其组织起来，每一张表都保存一个指向下一张表的 UID。表的二进制结构如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[TableName]</span><span class="selector-attr">[NextTable]</span></span><br><span class="line"><span class="selector-attr">[Field1Uid]</span><span class="selector-attr">[Field2Uid]</span>...<span class="selector-attr">[FieldNUid]</span></span><br></pre></td></tr></table></figure>

<p>​		这里由于每个 Entry 中的数据，字节数是确定的，于是无需保存字段的个数。根据 UID 从 Entry 中读取表数据的过程和读取字段的过程类似。 </p>
<p>​		对表和字段的操作，有一个很重要的步骤，就是计算 Where 条件的范围，目前 MYDB 的 Where 只支持两个条件的与和或。例如有条件的 Delete，计算 Where，最终就需要获取到条件范围内所有的 UID。MYDB 只支持已索引字段作为 Where 的条件。计算 Where 的范围，具体可以查看 Table 的 parseWhere() 和 calWhere() 方法，以及 Field 类的 calExp() 方法。 </p>
<p>​		由于 TBM 的表管理，使用的是链表串起的 Table 结构，所以就必须保存一个链表的头节点，即第一个表的 UID，这样在 MYDB 启动时，才能快速找到表信息。 </p>
<p>​		MYDB 使用 Booter 类和 bt 文件，来管理 MYDB 的启动信息，虽然现在所需的启动信息，只有一个：头表的 UID。Booter 类对外提供了两个方法：load 和 update，并保证了其原子性。update 在修改 bt 文件内容时，没有直接对 bt 文件进行修改，而是首先将内容写入一个 bt_tmp 文件中，随后将这个文件重命名为 bt 文件。以期通过操作系统重命名文件的原子性，来保证操作的原子性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">byte</span>[] data)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path + BOOTER_TMP_SUFFIX);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        tmp.createNewFile();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!tmp.canRead() || !tmp.canWrite()) &#123;</span><br><span class="line">        Panic.panic(Error.FileCannotRWException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(tmp)) &#123;</span><br><span class="line">        out.write(data);</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Files.move(tmp.toPath(), <span class="keyword">new</span> <span class="title class_">File</span>(path+BOOTER_SUFFIX).toPath(), StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        Panic.panic(e);</span><br><span class="line">    &#125;</span><br><span class="line">    file = <span class="keyword">new</span> <span class="title class_">File</span>(path+BOOTER_SUFFIX);</span><br><span class="line">    <span class="keyword">if</span>(!file.canRead() || !file.canWrite()) &#123;</span><br><span class="line">        Panic.panic(Error.FileCannotRWException);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="TableManager"><a href="#TableManager" class="headerlink" title="TableManager"></a>TableManager</h2><p>​		TBM 层对外提供服务的是 TableManager 接口，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TableManager</span> &#123;</span><br><span class="line">    BeginRes <span class="title function_">begin</span><span class="params">(Begin begin)</span>;</span><br><span class="line">    <span class="type">byte</span>[] commit(<span class="type">long</span> xid) <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">byte</span>[] abort(<span class="type">long</span> xid);</span><br><span class="line"> </span><br><span class="line">    <span class="type">byte</span>[] show(<span class="type">long</span> xid);</span><br><span class="line">    <span class="type">byte</span>[] create(<span class="type">long</span> xid, Create create) <span class="keyword">throws</span> Exception;</span><br><span class="line"> </span><br><span class="line">    <span class="type">byte</span>[] insert(<span class="type">long</span> xid, Insert insert) <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">byte</span>[] read(<span class="type">long</span> xid, Select select) <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">byte</span>[] update(<span class="type">long</span> xid, Update update) <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="type">byte</span>[] delete(<span class="type">long</span> xid, Delete delete) <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		由于 TableManager 已经是直接被最外层 Server 调用（MYDB 是 C&#x2F;S 结构），这些方法直接返回执行的结果，例如错误信息或者结果信息的字节数组（可读）。 各个方法的具体实现很简单，不再赘述，无非是调用 VM 的相关方法。唯一值得注意的一个小点是，在创建新表时，采用的是头插法，所以每次创建表都需要更新 Booter 文件。</p>
<h1 id="服务端客户端的实现及其通信规则"><a href="#服务端客户端的实现及其通信规则" class="headerlink" title="服务端客户端的实现及其通信规则"></a>服务端客户端的实现及其通信规则</h1><p>​		MyDB 被设计为 C&#x2F;S 结构，类似于 MySQL。支持启动一个服务器，并有多个客户端去连接，通过 socket 通信，执行 SQL 返回结果。</p>
<h2 id="C-x2F-S-通信"><a href="#C-x2F-S-通信" class="headerlink" title="C&#x2F;S 通信"></a>C&#x2F;S 通信</h2><h3 id="1、CS之间通信的基本结构-Package"><a href="#1、CS之间通信的基本结构-Package" class="headerlink" title="1、CS之间通信的基本结构 Package"></a>1、CS之间通信的基本结构 Package</h3><p>​		MYDB 使用了一种特殊的二进制格式，用于客户端和服务端通信。当然如果嫌麻烦的话，其实直接用明文也不是不可以。 传输的最基本结构，是 Package：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Package</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] data;</span><br><span class="line">    Exception err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、编码与解码规则"><a href="#2、编码与解码规则" class="headerlink" title="2、编码与解码规则"></a>2、编码与解码规则</h3><p>​		每个 Package 在发送前，由 Encoder 编码为字节数组，在对方收到后同样会由 Encoder 解码成 Package 对象。编码和解码的规则如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[Flag]</span><span class="selector-attr">[data]</span></span><br></pre></td></tr></table></figure>

<p>​		若 flag 为 0，表示发送的是数据，那么 data 即为这份数据本身；如果 flag 为 1，表示发送的是错误，data 是 Exception.getMessage() 的错误提示信息。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Encoder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] encode(Package pkg) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pkg.getErr() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Exception</span> <span class="variable">err</span> <span class="operator">=</span> pkg.getErr();</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Intern server error!&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(err.getMessage() != <span class="literal">null</span>) &#123;</span><br><span class="line">                msg = err.getMessage();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Bytes.concat(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>&#125;, msg.getBytes());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Bytes.concat(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>&#125;, pkg.getData());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Package <span class="title function_">decode</span><span class="params">(<span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(data.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> Error.InvalidPkgDataException;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(data[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Package</span>(Arrays.copyOfRange(data, <span class="number">1</span>, data.length), <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(data[<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Package</span>(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="keyword">new</span> <span class="title class_">String</span>(Arrays.copyOfRange(data, <span class="number">1</span>, data.length))));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> Error.InvalidPkgDataException;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、通过-Transporter-类，写入输出流发送信息"><a href="#3、通过-Transporter-类，写入输出流发送信息" class="headerlink" title="3、通过 Transporter 类，写入输出流发送信息"></a>3、通过 Transporter 类，写入输出流发送信息</h3><p>​		编码之后的信息会通过 Transporter 类，写入输出流发送出去。为了避免特殊字符造成问题，这里会将数据转成十六进制字符串（Hex String），并为信息末尾加上换行符。这样在发送和接收数据时，就可以很简单地使用 BufferedReader 和 Writer 来直接按行读写了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transporter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader reader;</span><br><span class="line">    <span class="keyword">private</span> BufferedWriter writer;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Transporter</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">        <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">        <span class="built_in">this</span>.writer = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream()));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(<span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">raw</span> <span class="operator">=</span> hexEncode(data);</span><br><span class="line">        writer.write(raw);</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] receive() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">        <span class="keyword">if</span>(line == <span class="literal">null</span>) &#123;</span><br><span class="line">            close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hexDecode(line);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        writer.close();</span><br><span class="line">        reader.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">hexEncode</span><span class="params">(<span class="type">byte</span>[] buf)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Hex.encodeHexString(buf, <span class="literal">true</span>)+<span class="string">&quot;n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] hexDecode(String buf) <span class="keyword">throws</span> DecoderException &#123;</span><br><span class="line">        <span class="keyword">return</span> Hex.decodeHex(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、Packager-中对外提供的-send-和-receive-方法"><a href="#4、Packager-中对外提供的-send-和-receive-方法" class="headerlink" title="4、Packager 中对外提供的 send 和 receive 方法"></a>4、Packager 中对外提供的 send 和 receive 方法</h3><p>​		Packager 则是 Encoder 和 Transporter 的结合体，直接对外提供 send 和 receive 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Packager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Transporter transpoter;</span><br><span class="line">    <span class="keyword">private</span> Encoder encoder;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Packager</span><span class="params">(Transporter transpoter, Encoder encoder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.transpoter = transpoter;</span><br><span class="line">        <span class="built_in">this</span>.encoder = encoder;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(Package pkg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = encoder.encode(pkg);</span><br><span class="line">        transpoter.send(data);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Package <span class="title function_">receive</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = transpoter.receive();</span><br><span class="line">        <span class="keyword">return</span> encoder.decode(data);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        transpoter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Server-和-Client-的实现"><a href="#Server-和-Client-的实现" class="headerlink" title="Server 和 Client 的实现"></a>Server 和 Client 的实现</h2><p>​		Server 和 Client，偷懒直接使用了 Java 的 socket。 </p>
<h3 id="1、服务端实现"><a href="#1、服务端实现" class="headerlink" title="1、服务端实现"></a>1、服务端实现</h3><p>​		Server 启动一个 ServerSocket 监听端口，当有请求到来时直接把请求丢给一个新线程处理。这部分应该直接背板了。 HandleSocket 类实现了 Runnable 接口，在建立连接后初始化 Packager，随后就循环接收来自客户端的数据并处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Packager</span> <span class="variable">packager</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Transporter</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transporter</span>(socket);</span><br><span class="line">    <span class="type">Encoder</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Encoder</span>();</span><br><span class="line">    packager = <span class="keyword">new</span> <span class="title class_">Packager</span>(t, e);</span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">        e1.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Executor</span> <span class="variable">exe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Executor</span>(tbm);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">Package</span> <span class="variable">pkg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pkg = packager.receive();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">byte</span>[] sql = pkg.getData();</span><br><span class="line">    <span class="type">byte</span>[] result = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Exception</span> <span class="variable">e</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = exe.execute(sql);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">        e = e1;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    pkg = <span class="keyword">new</span> <span class="title class_">Package</span>(result, e);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        packager.send(pkg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">        e1.printStackTrace();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		处理的核心是 Executor 类，Executor 调用 Parser 获取到对应语句的结构化信息对象，并根据对象的类型，调用 TBM 的不同方法进行处理。具体不再赘述。</p>
<p>​		top.guoziyang.mydb.backend.Launcher 类，则是服务器的启动入口。这个类解析了命令行参数。很重要的参数就是 -open 或者 -create。Launcher 根据两个参数，来决定是创建数据库文件，还是启动一个已有的数据库。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createDB</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="type">TransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> TransactionManager.create(path);</span><br><span class="line">    <span class="type">DataManager</span> <span class="variable">dm</span> <span class="operator">=</span> DataManager.create(path, DEFALUT_MEM, tm);</span><br><span class="line">    <span class="type">VersionManager</span> <span class="variable">vm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VersionManagerImpl</span>(tm, dm);</span><br><span class="line">    TableManager.create(path, vm, dm);</span><br><span class="line">    tm.close();</span><br><span class="line">    dm.close();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">openDB</span><span class="params">(String path, <span class="type">long</span> mem)</span> &#123;</span><br><span class="line">    <span class="type">TransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> TransactionManager.open(path);</span><br><span class="line">    <span class="type">DataManager</span> <span class="variable">dm</span> <span class="operator">=</span> DataManager.open(path, mem, tm);</span><br><span class="line">    <span class="type">VersionManager</span> <span class="variable">vm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VersionManagerImpl</span>(tm, dm);</span><br><span class="line">    <span class="type">TableManager</span> <span class="variable">tbm</span> <span class="operator">=</span> TableManager.open(path, vm, dm);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Server</span>(port, tbm).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、客户端的实现"><a href="#2、客户端的实现" class="headerlink" title="2、客户端的实现"></a>2、客户端的实现</h3><p>​		客户端连接服务器的过程，也是背板。客户端有一个简单的 Shell，实际上只是读入用户的输入，并调用 Client.execute()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] execute(<span class="type">byte</span>[] stat) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Package</span> <span class="variable">pkg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Package</span>(stat, <span class="literal">null</span>);</span><br><span class="line">    <span class="type">Package</span> <span class="variable">resPkg</span> <span class="operator">=</span> rt.roundTrip(pkg);</span><br><span class="line">    <span class="keyword">if</span>(resPkg.getErr() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> resPkg.getErr();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resPkg.getData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		RoundTripper 类实际上实现了单次收发动作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Package <span class="title function_">roundTrip</span><span class="params">(Package pkg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    packager.send(pkg);</span><br><span class="line">    <span class="keyword">return</span> packager.receive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		最后附上客户端的启动入口，很简单，把 Shell run 起来即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Launcher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">        <span class="type">Encoder</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Encoder</span>();</span><br><span class="line">        <span class="type">Transporter</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transporter</span>(socket);</span><br><span class="line">        <span class="type">Packager</span> <span class="variable">packager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Packager</span>(t, e);</span><br><span class="line"> </span><br><span class="line">        <span class="type">Client</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Client</span>(packager);</span><br><span class="line">        <span class="type">Shell</span> <span class="variable">shell</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Shell</span>(client);</span><br><span class="line">        shell.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="八股及结语"><a href="#八股及结语" class="headerlink" title="八股及结语"></a>八股及结语</h1><h2 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h2><p>结束撒花，感谢声哥的项目，做完之后对数据库的了解更深刻，最后，放一个声哥的版权。</p>
<p># 商业转载请联系作者获得授权，非商业转载请注明出处。<br># For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source.<br># 协议(License)：署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0)<br># 作者(Author)：Ziyang<br># 链接(URL)：<a target="_blank" rel="noopener" href="https://ziyang.moe/article/mydb0.html">https://ziyang.moe/article/mydb0.html</a><br># 来源(Source)：菜狗の日常</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>TT
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2022/04/29/MyDB/" title="MyDB数据库">http://example.com/2022/04/29/MyDB/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%A1%B9%E7%9B%AE/" rel="tag"># 项目</a>
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2022/07/26/hello-world/" rel="next" title="Hello World">
      Hello World <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#MyDB-%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">MyDB 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">整体结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%80%E9%9C%80%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-number">1.2.</span> <span class="nav-text">所需知识点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%8E%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84-TM-%E5%BC%80%E5%A7%8B"><span class="nav-number">2.</span> <span class="nav-text">从最简单的 TM 开始</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#XID-%E6%96%87%E4%BB%B6%E7%AE%80%E4%BB%8B"><span class="nav-number">2.1.</span> <span class="nav-text">XID 文件简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BATM%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.1.1.</span> <span class="nav-text">创建TM接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F%E5%92%8C%E5%B1%9E%E6%80%A7"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.定义常量和属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%A0%A1%E9%AA%8C-XID-%E6%96%87%E4%BB%B6%E4%BF%9D%E8%AF%81%E5%85%B6%E5%90%88%E6%B3%95%E6%80%A7"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.校验 XID 文件保证其合法性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%9B%B4%E6%96%B0%E4%BA%8B%E5%8A%A1%E7%8A%B6%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E6%9B%B4%E6%96%B0XID%E6%96%87%E4%BB%B6%E5%A4%B4%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.3.</span> <span class="nav-text">3.更新事务状态方法和更新XID文件头方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%88%9B%E5%BB%BA-begin-%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%B3%95%E3%80%81%E5%88%9B%E5%BB%BA%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%B3%95%E3%80%81%E5%88%9B%E5%BB%BA%E5%9B%9E%E6%BB%9A%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.4.</span> <span class="nav-text">4.创建 begin 事务方法、创建提交事务方法、创建回滚事务方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%88%9B%E5%BB%BA-isActive%E3%80%81isCommitted-%E5%92%8C-isAborted-%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.5.</span> <span class="nav-text">5.创建 isActive、isCommitted 和 isAborted 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%85%B3%E9%97%AD%E8%B5%84%E6%BA%90"><span class="nav-number">2.2.6.</span> <span class="nav-text">6.关闭资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81%E6%8E%A5%E5%8F%A3%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.7.</span> <span class="nav-text">7、接口静态方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E5%92%8C%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%95%B0%E7%BB%84"><span class="nav-number">3.</span> <span class="nav-text">引用计数缓存框架和共享内存数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AD%96%E7%95%A5%E7%9A%84%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6"><span class="nav-number">3.1.</span> <span class="nav-text">实现引用计数策略的缓存框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%EF%BC%9A%E4%B8%8D%E5%9C%A8%E7%BC%93%E5%AD%98%E7%9A%84%E8%B5%84%E6%BA%90%E8%8E%B7%E5%8F%96%EF%BC%8C%E8%A2%AB%E9%A9%B1%E9%80%90%E7%9A%84%E8%B5%84%E6%BA%90%E5%86%99%E5%9B%9E"><span class="nav-number">3.1.1.</span> <span class="nav-text">1、抽象方法：不在缓存的资源获取，被驱逐的资源写回</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81get-%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.2.</span> <span class="nav-text">2、get();获取资源方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81release-%E9%87%8A%E6%94%BE%E7%BC%93%E5%AD%98%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.3.</span> <span class="nav-text">3、release();释放缓存方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81close-%E5%85%B3%E9%97%AD%E7%BC%93%E5%AD%98%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.4.</span> <span class="nav-text">4、close();关闭缓存方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%95%B0%E7%BB%84"><span class="nav-number">3.2.</span> <span class="nav-text">实现共享内存数组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E7%AE%A1%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">数据页的缓存与管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.1.</span> <span class="nav-text">数据页面缓存的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84"><span class="nav-number">4.1.1.</span> <span class="nav-text">1、定义页面结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.1.2.</span> <span class="nav-text">2、定义页面缓存的接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">4.1.3.</span> <span class="nav-text">3、页面缓存的具体实现类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E8%AE%B0%E5%BD%95%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6%E7%9A%84%E9%A1%B5%E6%95%B0"><span class="nav-number">4.1.4.</span> <span class="nav-text">4、记录数据库文件的页数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.2.</span> <span class="nav-text">数据页面管理实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%AC%AC%E4%B8%80%E9%A1%B5%E8%AE%BE%E8%AE%A1"><span class="nav-number">4.2.1.</span> <span class="nav-text">1、第一页设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%99%AE%E9%80%9A%E9%A1%B5%E8%AE%BE%E8%AE%A1"><span class="nav-number">4.2.2.</span> <span class="nav-text">2、普通页设计</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E4%B8%8E%E6%81%A2%E5%A4%8D%E7%AD%96%E7%95%A5"><span class="nav-number">5.</span> <span class="nav-text">日志文件与恢复策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E8%AF%BB%E5%86%99%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.1.</span> <span class="nav-text">日志读写实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%97%A5%E5%BF%97%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-number">5.1.1.</span> <span class="nav-text">1、日志的格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%B1%82%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E7%9A%84%E6%A0%A1%E9%AA%8C%E5%92%8C"><span class="nav-number">5.1.2.</span> <span class="nav-text">2、求单条日志的校验和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E8%AF%BB%E5%8F%96%E6%97%A5%E5%BF%97%E5%B9%B6%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE"><span class="nav-number">5.1.3.</span> <span class="nav-text">3、读取日志并返回数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E6%A3%80%E9%AA%8C%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="nav-number">5.1.4.</span> <span class="nav-text">4、检验日志文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E5%90%91%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%97%A5%E5%BF%97"><span class="nav-number">5.1.5.</span> <span class="nav-text">5、向日志文件写入日志</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D%E7%AD%96%E7%95%A5"><span class="nav-number">5.2.</span> <span class="nav-text">恢复策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.2.1.</span> <span class="nav-text">1、单线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.2.2.</span> <span class="nav-text">2、多线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D%E7%AD%96%E7%95%A5%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.3.</span> <span class="nav-text">恢复策略的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E8%A7%84%E5%AE%9A%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F"><span class="nav-number">5.3.1.</span> <span class="nav-text">1、规定日志格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%AE%9E%E7%8E%B0-recover-%E4%BE%8B%E7%A8%8B"><span class="nav-number">5.3.2.</span> <span class="nav-text">2、实现 recover 例程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81updateLog-%E5%92%8C-insertLog-%E7%9A%84%E9%87%8D%E5%81%9A%E5%92%8C%E6%92%A4%E9%94%80%E5%A4%84%E7%90%86"><span class="nav-number">5.3.3.</span> <span class="nav-text">3、updateLog 和 insertLog 的重做和撤销处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%B4%A2%E5%BC%95%E5%92%8C-DM-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.</span> <span class="nav-text">页面索引和 DM 的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.1.</span> <span class="nav-text">页面索引实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81PageIndex-%E9%A1%B5%E9%9D%A2%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.1.1.</span> <span class="nav-text">1、PageIndex 页面索引的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BB%8E-PageIndex-%E4%B8%AD%E8%8E%B7%E5%8F%96%E9%A1%B5%E9%9D%A2"><span class="nav-number">6.1.2.</span> <span class="nav-text">2、从 PageIndex 中获取页面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E9%A1%B5%E9%9D%A2%E9%87%8D%E6%96%B0%E6%8F%92%E5%85%A5-PageIndex-%E4%B8%AD"><span class="nav-number">6.1.3.</span> <span class="nav-text">3、页面重新插入 PageIndex 中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%88%9B%E5%BB%BA-DM-%E6%97%B6%E6%89%80%E9%9C%80%E7%9A%84%E5%B7%A5%E4%BD%9C"><span class="nav-number">6.1.4.</span> <span class="nav-text">4、创建 DM 时所需的工作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DataItem-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.2.</span> <span class="nav-text">DataItem 的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81DataItem-%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84"><span class="nav-number">6.2.1.</span> <span class="nav-text">1、DataItem 的结构和日志结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81data-%E6%96%B9%E6%B3%95%E8%8E%B7%E5%8F%96-DataItem-%E6%95%B0%E6%8D%AE"><span class="nav-number">6.2.2.</span> <span class="nav-text">2、data();方法获取 DataItem 数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E4%BF%AE%E6%94%B9-DataItem-%E7%9A%84%E7%9B%B8%E5%85%B3-before-unBefore-after-%E6%96%B9%E6%B3%95"><span class="nav-number">6.2.3.</span> <span class="nav-text">3、修改 DataItem 的相关 before();unBefore();after() 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81release-%E6%96%B9%E6%B3%95%E9%87%8A%E6%94%BE-DataItem-%E7%BC%93%E5%AD%98"><span class="nav-number">6.2.4.</span> <span class="nav-text">4、release(); 方法释放 DataItem 缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DM-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.3.</span> <span class="nav-text">DM 的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E8%A7%A3%E6%9E%90-DM-%E7%9A%84-DataItem-%E7%BC%93%E5%AD%98%EF%BC%8C%E5%B9%B6%E8%8E%B7%E5%8F%96%E5%85%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">6.3.1.</span> <span class="nav-text">1、解析 DM 的 DataItem 缓存，并获取其中的数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E9%87%8A%E6%94%BE-DM-%E7%9A%84-DataItem-%E7%BC%93%E5%AD%98%EF%BC%8C%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%86%99%E5%9B%9E%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="nav-number">6.3.2.</span> <span class="nav-text">2、释放 DM 的 DataItem 缓存，把数据写回数据源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%88%9B%E5%BB%BA-DataManager-%E6%96%87%E4%BB%B6"><span class="nav-number">6.3.3.</span> <span class="nav-text">3、创建 DataManager 文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%96%E6%A3%80%E9%AA%8C-DM-%E6%96%87%E4%BB%B6%E7%AC%AC%E4%B8%80%E9%A1%B5"><span class="nav-number">6.3.4.</span> <span class="nav-text">4、初始化或检验 DM 文件第一页</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81read-insert-DM-%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0-R-%E5%92%8C-I"><span class="nav-number">6.3.5.</span> <span class="nav-text">5、read();insert(); DM 方法实现 R 和 I</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81close-%E6%96%B9%E6%B3%95%EF%BC%8C%E5%85%B3%E9%97%AD-DM"><span class="nav-number">6.3.6.</span> <span class="nav-text">6、close();方法，关闭 DM</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E7%9A%84%E7%89%88%E6%9C%AC%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB"><span class="nav-number">7.</span> <span class="nav-text">记录的版本与事务隔离</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MVCC"><span class="nav-number">7.1.</span> <span class="nav-text">MVCC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.2.</span> <span class="nav-text">记录的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%AD%98%E5%9C%A8-Data-Item-%E4%B8%AD%E8%AE%B0%E5%BD%95"><span class="nav-number">7.2.1.</span> <span class="nav-text">1、存在 Data Item 中记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Entry-%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="nav-number">7.2.2.</span> <span class="nav-text">2、Entry 中存储的数据格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E8%8E%B7%E5%8F%96%E8%AE%B0%E5%BD%95%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">7.2.3.</span> <span class="nav-text">3、获取记录中的数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E4%BF%AE%E6%94%B9%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE"><span class="nav-number">7.2.4.</span> <span class="nav-text">4、修改返回数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">7.3.</span> <span class="nav-text">事务的隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4-Read-Committed"><span class="nav-number">7.3.1.</span> <span class="nav-text">1、读已提交 Read Committed</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB-Repeatable-Read"><span class="nav-number">7.3.2.</span> <span class="nav-text">2、可重复读  Repeatable Read</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E4%B8%8E-VM-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.</span> <span class="nav-text">死锁检测与 VM 的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%98"><span class="nav-number">8.1.</span> <span class="nav-text">版本跳跃问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%89%88%E6%9C%AC%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%98%E4%B8%BE%E4%BE%8B"><span class="nav-number">8.1.1.</span> <span class="nav-text">1、版本跳跃问题举例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%89%88%E6%9C%AC%E8%B7%B3%E8%B7%83%E6%A3%80%E6%9F%A5%E8%A7%A3%E5%86%B3"><span class="nav-number">8.1.2.</span> <span class="nav-text">2、版本跳跃检查解决</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="nav-number">8.2.</span> <span class="nav-text">死锁检测</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%AD%89%E5%BE%85%E5%85%B3%E7%B3%BB%E6%8A%BD%E8%B1%A1%E4%B8%BA%E5%9B%BE%E7%9A%84%E5%9B%BE%E7%BB%93%E6%9E%84"><span class="nav-number">8.2.1.</span> <span class="nav-text">1、等待关系抽象为图的图结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E9%81%87%E5%88%B0%E7%AD%89%E5%BE%85%E9%9C%80%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81"><span class="nav-number">8.2.2.</span> <span class="nav-text">2、遇到等待需检测死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E7%BB%A7%E7%BB%AD%E7%AD%89%E5%BE%85"><span class="nav-number">8.2.3.</span> <span class="nav-text">3、继续等待</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E9%80%9A%E8%BF%87%E6%9F%A5%E7%9C%8B%E5%9B%BE%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%E6%9D%A5%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81"><span class="nav-number">8.2.4.</span> <span class="nav-text">4、通过查看图中是否有环来检测死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">8.2.5.</span> <span class="nav-text">5、释放锁的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VM-%E7%9A%84%E6%95%B4%E5%90%88%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.3.</span> <span class="nav-text">VM 的整合实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81VM-%E6%8E%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.3.1.</span> <span class="nav-text">1、VM 接口参数和基本方法的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81begin-commit-internAbort-%E6%96%B9%E6%B3%95%E5%AF%B9%E4%BA%8B%E5%8A%A1%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="nav-number">8.3.2.</span> <span class="nav-text">2、begin();commit();internAbort();方法对事务进行操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81red-insert-delete-%E6%96%B9%E6%B3%95%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="nav-number">8.3.3.</span> <span class="nav-text">3、red();insert();delete(); 方法对数据进行操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%AE%A1%E7%90%86"><span class="nav-number">9.</span> <span class="nav-text">索引管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="nav-number">9.1.</span> <span class="nav-text">二叉树索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E6%9E%84"><span class="nav-number">9.1.1.</span> <span class="nav-text">1、二叉树结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%A0%B9%E8%8A%82%E7%82%B9%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">9.1.2.</span> <span class="nav-text">2、根节点的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81searchNex-leafSearchRange-%E6%96%B9%E6%B3%95%E7%94%A8%E4%BA%8E%E8%BE%85%E5%8A%A9-B-%E6%A0%91%E5%81%9A%E6%8F%92%E5%85%A5%E5%92%8C%E6%90%9C%E7%B4%A2%E6%93%8D%E4%BD%9C"><span class="nav-number">9.1.3.</span> <span class="nav-text">3、searchNex(); leafSearchRange(); 方法用于辅助 B+ 树做插入和搜索操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E8%AE%BE%E7%BD%AE-bootDataItem-%E9%80%82%E5%BA%94%E6%A0%B9%E8%8A%82%E7%82%B9%E7%9A%84%E8%B0%83%E6%95%B4"><span class="nav-number">9.1.4.</span> <span class="nav-text">4、设置 bootDataItem 适应根节点的调整</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%83%BD%E7%9A%84%E9%94%99%E8%AF%AF%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="nav-number">9.2.</span> <span class="nav-text">可能的错误与恢复</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E4%B8%8E%E8%A1%A8%E7%AE%A1%E7%90%86"><span class="nav-number">9.3.</span> <span class="nav-text">字段与表管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%8D%95%E4%B8%AA%E5%AD%97%E6%AE%B5%E4%BF%A1%E6%81%AF%E5%92%8C%E8%A1%A8%E4%BF%A1%E6%81%AF%E7%9A%84%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">9.3.0.1.</span> <span class="nav-text">1、单个字段信息和表信息的储存结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%A0%B9%E6%8D%AE-UID-%E8%AF%BB%E5%8F%96%E5%B9%B6%E8%A7%A3%E6%9E%90%E5%8D%95%E4%B8%AA%E5%AD%97%E6%AE%B5%E5%92%8C%E8%A1%A8%E4%BF%A1%E6%81%AF"><span class="nav-number">9.3.0.2.</span> <span class="nav-text">2、根据 UID 读取并解析单个字段和表信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96%E4%BF%A1%E6%81%AF"><span class="nav-number">9.3.0.3.</span> <span class="nav-text">3、持久化信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E9%93%BE%E8%A1%A8%E7%AE%A1%E7%90%86%E7%AE%A1%E7%90%86%E5%A4%9A%E5%BC%A0%E8%A1%A8"><span class="nav-number">9.3.0.4.</span> <span class="nav-text">4、链表管理管理多张表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TableManager"><span class="nav-number">9.4.</span> <span class="nav-text">TableManager</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%85%B6%E9%80%9A%E4%BF%A1%E8%A7%84%E5%88%99"><span class="nav-number">10.</span> <span class="nav-text">服务端客户端的实现及其通信规则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-x2F-S-%E9%80%9A%E4%BF%A1"><span class="nav-number">10.1.</span> <span class="nav-text">C&#x2F;S 通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81CS%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84-Package"><span class="nav-number">10.1.1.</span> <span class="nav-text">1、CS之间通信的基本结构 Package</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81%E8%A7%84%E5%88%99"><span class="nav-number">10.1.2.</span> <span class="nav-text">2、编码与解码规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E9%80%9A%E8%BF%87-Transporter-%E7%B1%BB%EF%BC%8C%E5%86%99%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E5%8F%91%E9%80%81%E4%BF%A1%E6%81%AF"><span class="nav-number">10.1.3.</span> <span class="nav-text">3、通过 Transporter 类，写入输出流发送信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81Packager-%E4%B8%AD%E5%AF%B9%E5%A4%96%E6%8F%90%E4%BE%9B%E7%9A%84-send-%E5%92%8C-receive-%E6%96%B9%E6%B3%95"><span class="nav-number">10.1.4.</span> <span class="nav-text">4、Packager 中对外提供的 send 和 receive 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Server-%E5%92%8C-Client-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.2.</span> <span class="nav-text">Server 和 Client 的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.2.1.</span> <span class="nav-text">1、服务端实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.2.2.</span> <span class="nav-text">2、客户端的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E8%82%A1%E5%8F%8A%E7%BB%93%E8%AF%AD"><span class="nav-number">11.</span> <span class="nav-text">八股及结语</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB%E8%82%A1"><span class="nav-number">11.1.</span> <span class="nav-text">八股</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="TT"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">TT</p>
  <div class="site-description" itemprop="description">All troubles are self-inflicted.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/DDDDSG" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;DDDDSG" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/62531488?spm_id_from=333.1007.0.0" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;62531488?spm_id_from&#x3D;333.1007.0.0" rel="noopener" target="_blank"><i class="fa fa-bold fa-fw"></i>bilibili</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://javaguide.cn/" title="https:&#x2F;&#x2F;javaguide.cn&#x2F;" rel="noopener" target="_blank">JavaGuide</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.programmercarl.com/" title="https:&#x2F;&#x2F;www.programmercarl.com&#x2F;" rel="noopener" target="_blank">Leetcode-master</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TT</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">85k</span>
    
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:17</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  















  

  

  

</body>
</html>
