<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="​		本项目是为了我们学校研究生学院方便学术交流和生活分享的平台。主要使用了Spring Boot、Mybatis、MySQL、Redis、kafka等工具，实现了用户的注册、登录、点赞、评论、系统通知、热度排行、搜索等功能，使用Redis提升了网站的性能，实现了用户凭证的存取、点赞关注的功能。基于 Kafka 实现了系统通知功能，当用户获得点赞、评论后得到通知。利用定时任务定期计算帖子的分数，并">
<meta property="og:type" content="article">
<meta property="og:title" content="论坛项目">
<meta property="og:url" content="http://example.com/2022/07/29/%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/index.html">
<meta property="og:site_name" content="U Boy TT">
<meta property="og:description" content="​		本项目是为了我们学校研究生学院方便学术交流和生活分享的平台。主要使用了Spring Boot、Mybatis、MySQL、Redis、kafka等工具，实现了用户的注册、登录、点赞、评论、系统通知、热度排行、搜索等功能，使用Redis提升了网站的性能，实现了用户凭证的存取、点赞关注的功能。基于 Kafka 实现了系统通知功能，当用户获得点赞、评论后得到通知。利用定时任务定期计算帖子的分数，并">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/Blog/source/imags/image-20220729223155410.png">
<meta property="og:image" content="http://example.com/imags/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21jY2FuZDEyMzQ=,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="http://example.com/imags/image-20220817163044027.png">
<meta property="article:published_time" content="2022-07-29T14:17:49.043Z">
<meta property="article:modified_time" content="2022-08-17T08:51:18.489Z">
<meta property="article:author" content="TT">
<meta property="article:tag" content="项目">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="Spring Boot">
<meta property="article:tag" content="SSM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/Blog/source/imags/image-20220729223155410.png">

<link rel="canonical" href="http://example.com/2022/07/29/%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>论坛项目 | U Boy TT</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">U Boy TT</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>资源</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/29/%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="TT">
      <meta itemprop="description" content="All troubles are self-inflicted.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="U Boy TT">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          论坛项目
        </h1>

        <div class="post-meta">

	
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-29 22:17:49" itemprop="dateCreated datePublished" datetime="2022-07-29T22:17:49+08:00">2022-07-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-17 16:51:18" itemprop="dateModified" datetime="2022-08-17T16:51:18+08:00">2022-08-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E5%8F%8A%E6%95%B4%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">项目学习及整理</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>​		本项目是为了我们学校研究生学院方便学术交流和生活分享的平台。主要使用了Spring Boot、Mybatis、MySQL、Redis、kafka等工具，实现了用户的注册、登录、点赞、评论、系统通知、热度排行、搜索等功能，使用Redis提升了网站的性能，实现了用户凭证的存取、点赞关注的功能。基于 Kafka 实现了系统通知功能，当用户获得点赞、评论后得到通知。利用定时任务定期计算帖子的分数，并在页面上展现热帖排行榜。<span id="more"></span></p>
<h1 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h1><p>​		本项目是为了我们学校研究生学院方便学术交流和生活分享的平台。主要使用了Spring Boot、Spring、SpingMVC、Mybatis、MySQL、Redis、kafka、Elasticsearch 等工具，主要实现了 1）用户的注册、登录功能；2）发帖并对帖子的点赞、评论功能；3）对其他用户的私聊、关注功能；4）收到点赞评论私信关注能收到系统通知功能；5）敏感词过滤；6）帖子热度排行自动排行；7）另外也支持全文搜索功能。</p>
<p><img src="/../../../../Blog/source/imags/image-20220729223155410.png" alt="image-20220729223155410"></p>
<p>​		使用 Redis 提升了网站的性能，实现了用户凭证的存取、点赞关注的功能。</p>
<p>​		基于 Kafka 实现了系统通知功能，当用户获得点赞、评论后得到通知。利用定时任务定期计算帖子的分数，并在页面上展现热帖排行榜。</p>
<p>​		使用 SpringSecurity 重构了用户权限控制，版主、管理员设置不同权限来置顶、删除、加精。</p>
<p>​		使用 ElasticSearch 缓存帖子，再通过关键字搜索，高亮显示帖子列表，实现了全文检索功能。</p>
<p>​		前缀树：敏感词过滤。</p>
<h1 id="所用工具"><a href="#所用工具" class="headerlink" title="所用工具"></a>所用工具</h1><h2 id="Redis-一站式高性能存储方案"><a href="#Redis-一站式高性能存储方案" class="headerlink" title="Redis 一站式高性能存储方案"></a>Redis 一站式高性能存储方案</h2><h3 id="Redis-介绍与作用"><a href="#Redis-介绍与作用" class="headerlink" title="Redis 介绍与作用"></a>Redis 介绍与作用</h3><p>​		Redis是一款基于键值对的NoSQL（Not only sql：非关系型数据库）数据库，它的值支持多种数据结构；字符串(String)、哈希(hashes)、列表(lists)、集合（zset）、有序集合(sorted sets)。Redis 能将所有经常访问的数据存放在内存中，提高系统读写能力；同时，Redis 还有持久化机制保证数据的安全性。可以将内存中的数据以快照（将内存中的数据原封原样的存放到硬盘上，但是效率较低，可能会有阻塞，不适合实时的做）或日志（存的是Redis的操作命令，可以实时存储，但是恢复时很慢）的形式保存在硬盘上，以保证数据的安全性，不会因为关闭系统而丢失数据；</p>
<h3 id="Redis-在论坛项目中的应用"><a href="#Redis-在论坛项目中的应用" class="headerlink" title="Redis 在论坛项目中的应用"></a>Redis 在论坛项目中的应用</h3><p>​	缓存：（热门数据缓存：将访问频繁的数据存入缓存），合理的利用缓存不仅能够提升网站的访问速度，还能大大降低数据库的压力。</p>
<p>​	排行榜：（热贴排行：点赞评论访问频繁的帖子的访问量高），Redis 提供有序集合数据结构能够实现复杂的排行榜应用。</p>
<p>​	计数器：（帖子的计数器：计数器的值变化很快，为了保证数据实时有效，每次浏览都会+1，并发量高时，如果每次都请求数据库操作无疑是巨大的压力），Redis 提供 incr（increment、decrement）命令来实现计数器功能，内存操作，性能非常好，适用于这些计数器场景。</p>
<p>​	社交网络：（点赞、关注、关注、私聊等是社交网站的基本功能，社交网站的访问量通常较大）、传统的关系型数据库不适合存储这种类型的数据，Redis 提供的哈希、集合等数据结构能很方便的使用这些功能；</p>
<p>​	补充 Redis 额外的功能，分布式会话：集群模式下，在应用不多的情况下一般使用容器自带的 session 复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建以 Redis 等内存数据库为中心的 session 服务，session 不再由容器管理，而是由 session 服务以及内存数据库管理，可以实现集群中不同服务器对消息响应的一致性。</p>
<p>​	充当消息队列，由于 Redis 的列表是使用双向链表实现的，保存了头尾节点，所以在列表的头尾两边插取元素都是非常快的。所以可以直接使用 Redis的 List 实现消息队列，只需要简单的两个指令 lpush(从左端添加)和 rpop(从右端读取)或者是 rpush(从右端添加)和 lpop (从左端读取)。</p>
<h3 id="Redis-数据类型在项目中的应用"><a href="#Redis-数据类型在项目中的应用" class="headerlink" title="Redis 数据类型在项目中的应用"></a>Redis 数据类型在项目中的应用</h3><p>​	Redis 的数据类型：String、Hash 是 String 类型的 field-value（键值对） 的映射表、List 双向链表、Set 无序集合、ZSet 有序集合、Bitmap 二进制数字（0 和 1）、HyperLogLog 基数计数概率算法</p>
<p>​	用户点赞：方案一：采用 String 存放整数，点赞后字符串内数字就 +1。方案二：为了后续功能升级比如想知道是谁点赞的，采用 Set(userId) 类型储存，谁点过赞了就存到集合里，Set 也有统计数量的方法，可以知道点赞总数，也知道点赞的 id。</p>
<p>​	用户关注：ZSet(entityId,now)，被关注者，关注的时间为 score。设置关注的时间作为分数进行排序，是为了能在打开关注列表的时候，能清楚的按照时间顺序显示。</p>
<p>​	用户粉丝：ZSet(userId,now)，同理，粉丝列表显示关注时间。</p>
<p>​	验证码：方案一：存在 session 中，但是分布式部署存在 Session 共享问题。方案二：存放在 Redis （采用 String 数据类型来存放验证码英文数字），解决分布式部署的问题，而且能设置有效时间超时就失效，验证码是频繁访问和刷新的对性能要求高，所以使用 Redis。</p>
<p>​	登陆凭证：方案一：在每次处理请求的时候拦截器都会查询用户的登录凭证，访问比较频繁，性能较低。方案二：存放在 Redis ，采用String数据格式。</p>
<p>​	缓存用户信息：后台在每次处理请求的时候都要根据用户的凭证获取用户信息，访问的频率非常高。</p>
<p>​	帖子分数：计算公式计算帖子分数，把帖子 id 和分数都存入 redis 的 ZSet 。</p>
<p>​	UV 独立访客（Unique Visitor）：HyperLogLog， 常用大数据量的去重统计（小数据量去重可采用Set 集合），占 12k 的内存就能存储接近<code>2^64</code>个不同元素，是不精准统计算法（估算）。</p>
<p>​	DAU 单日活跃用户（Daily Active User）：BitMap 0&#x2F;1构成的 byte 数组，适合需要保存状态信息（0&#x2F;1 即可表示）的场景，如用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</p>
<p>​	区间活跃用户：Bitmap 同上。</p>
<h3 id="Redis-八股文"><a href="#Redis-八股文" class="headerlink" title="Redis 八股文"></a>Redis 八股文</h3><p>1、Redis 是单线程的，如何提高多核 CPU 的利用率？ </p>
<p>​		在同一个服务器部署多个Redis实例，并将它们当作不同的服务器使用。使用多个cpu，可以使用 shard 分片。</p>
<p>2、Redis 的持久化机制是什么？各自的优缺点？ </p>
<p>​	Redis由于是存储在计算机内存之中，但是当内存断电或者Redis重启后其中数据都会丢失，持久化机制就是为了保证Redis在重启后数据不丢失。</p>
<p>​	Redis数据从内存中以某种形式同步到硬盘内，使得重启后根据硬盘中的记录恢复数据。持久化机制保证 Redis 挂掉之后再重启，数据可以进行恢复，一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</p>
<p>​	RDB（默认）：创建快照来获取保存储存在内存里的数据各个时间点的副本，保存在本地可用来重启恢复，复制到其他服务器可创建校内沟通数据的服务器（Redis 主从结构）<br>​	AOF（主流）：实时性更好，Redis 就会将改写 Redis 中数据的命令写入到内存缓存，然后再根据配置来决定何时将其同步到硬盘中的 AOF 文件。</p>
<p>3、Redis线程模型、单线程快的原因 </p>
<p>​		Redis单线程的。没有多线程情况下各种加锁释放锁的性能消耗，或者出现死锁的情况；更没有多线程情况下多线程切换导致的 CPU 的消耗问题。</p>
<p>4、Redis的过期键的删除策略 </p>
<p>​		1）惰性删除：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。2）定期删除：定时抽取一批key执行删除过期key操作。对CPU的影响校大。</p>
<p>5、Redis 快的原因</p>
<p>​		1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速，数据存储在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p>
<p>​		2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门设计的；</p>
<p>​		3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁和释放锁的操作，没有因为可能出现死锁而导致的性能消耗；</p>
<p>​		4、使用多路I&#x2F;O复用模型，非阻塞I&#x2F;O。</p>
<p>6、<a href="">Redis</a> 主从复制的核心原理 </p>
<p>​		是将一个主服务器上的所有数据同步到从服务器上，使得主服务器和从服务器保持一致Redis主从复制可将写入的操作交给主服务器完成，而将读取操作交给从服务器完成，这样可以实现高并发。而实现主从复制的方式是通过异步同步的方式完成的，主要是全量同步和增量同步两种。</p>
<p>7、什么是 <a href="">Redis</a> 集群，集群方案 </p>
<p>​		Redis集群主要是将数据进行分片，不同的数据落到不同的节点上，每个节点存储1&#x2F;N的数据，这样当集群中的某些节点失效时，其他节点可以正常工作，实现高可用。</p>
<p>数据分片的原理：哈希算法。</p>
<p>​		twemproxy：以代理的身份接受请求并使用一致性哈希算法，将请求转接到具体Redis，结果再返回。</p>
<p>​		coids：和上面twemproxy基本一致， 但它支持在节点数量改变情况下，旧节点数据可恢复到新hash节点。</p>
<p>​		Redis cluster3.0：自带集群，分布式算法使用hash槽 </p>
<p>8、修改配置不重启 Redis 会实时生效吗？ </p>
<p>​		对运行实例，大多数配置可以通过config set命令修改，无需重启。</p>
<p>​		但是如果config命令不支持的配置参数则需要重启，比如升级Redis。</p>
<p>9、如何实现集群中的 session 共享存储？ </p>
<p>​		搭建以 Redis 等内存数据库为中心的 session 服务，session 不再由容器管理，而是由 session 服务以及内存数据库管理，可以实现集群中不同服务器对消息响应的一致性。</p>
<p>10、Redis 的内存用完了会发生什么？ </p>
<p>​	 如果达到设置内存的上限，Redis 的写命令会返回错误信息（但是读命令还可以正常返回。）</p>
<p>​	 或者你可以将 Redis 当缓存来使用配置淘汰机制，当 Redis 达到内存上限时会冲刷掉旧的内容，即 Redis 内存淘汰机制：6+2种内存淘汰策略。</p>
<p>11、缓存雪崩、缓存穿透、缓存击穿 </p>
<p>​		缓存穿透：请求从数据库查询一个数据库里没有的数据，故不写入缓存。这将导致每次查询这个不存在的数据都要到数据库查询，缓存失去了意义，就像被穿透了，导致数据库扛不住请求洪峰。</p>
<p>​		解决：接口请求参数校验，最大程度过滤非法参数；数据库返回空值时可以啊将空值缓存到Redis；使用布隆过滤器【布隆过滤器用于存储所有可能被访问的key，不存在的key直接过滤。存在的可以进一步查询数据库或者Redis】。</p>
<p>​		缓存击穿：一个热点的key，在缓存过期的一瞬间突然有大量请求同时过来，导致大量请求直接查询数据库，造成数据库请求量巨大压力骤增。</p>
<p>​		解决：加互斥锁，热点key过期后，大量请求涌入只有第一个请求能获取锁并阻塞，在从数据库获取数据并写入Redis缓存时释放锁，后续请求直接走缓存；设置缓存不过期或者让后台线程一直给热点数据缓存续期。</p>
<p>​		缓存雪崩：大量的热点key过期时间相同，导致数据在同一时刻集体失效，造成数据库瞬时压力巨大。</p>
<p>​		解决：将热点key的过期时间打散【过期时间加随机值】；加互斥锁；设置缓存不过期或者让后台线程一直给热点数据缓存续期；</p>
<p>12、使用 Redis 有哪些好处？ 为什么使用Redis?</p>
<p>​		1、Redis 数据库数据都存储在内存中，所以响应快速</p>
<p>​		2、支持多种数据类型，可以满足各种数据结构体的需要</p>
<p>​		3、操作都是原子性的，适合高并发</p>
<p>​		4、Redis 可以在缓存【每个键可以设置生存时间TTL、限定数据占用空间】，消息队列中使用</p>
<p>13、Redis数据类型有哪些？	</p>
<p>​		Key：String</p>
<p>​		Value：String、hash、list、set、sorted set、bitmap、hyperloglog</p>
<p>​		string 字符串、list 集合、set 不可重复集合、zset 带分数集合【排序集合】、hash 键值对。</p>
<p>14、Zset 和Java 的set有什么区别？Zset的底层实现是什么？</p>
<p>​		Zset 为有序集合类型，string类型元素集合，且不允许重复成员。</p>
<p>​		不同的就是每个元素会关联一个 double 类型的分数，通过这个分数实现有序。</p>
<p>​		zset 底层使用哈希表和跳表实现</p>
<p>15、Redis 跳表(跳跃表)</p>
<p>​		跳表（skiplist）是另一种实现dict的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">数据结构</a>。跳表是对链表的一个增强。我们在使用链表的时候，即使元素的有序排列的，但如果要查找一个元素，也需要从头一个个查找下去，时间复杂度是O(N)。而跳表顾名思义，就是跳跃了一些元素，可以抽象多层。</p>
<p>​		如下图所示，比如我们要查找8，先在最上层L2查找，发现在1和9之间；然后去L1层查找，发现在5和9之间；然后去L0查找，发现在7和9之间，然后找到8。</p>
<p>​		<img src="/../imags/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21jY2FuZDEyMzQ=,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p>​		当元素比较多时，使用跳表可以显著减少查找的次数。Redis内部也不是直接使用的跳表，而是使用了一个自定义的数据结构来持有跳表。</p>
<p>16、布隆过滤器</p>
<p>​		用于解决缓存穿透的方案之一。主要就是在一个存在一定数量的集合中过滤一个元素，判断该元素是否一定不在集合中或者可能在集合中。</p>
<p>​		优点：空间和时间效率都比一般算法好很多。缺点：存在一定的识别率问题和删除困难。</p>
<p>​		原理：几个 hash 算法和一张bit数组，一个 key 通过几个 hash 算法得到的值作为索引在 bit 数组中对应的默认值都从 0 修改为 1，当一个key经过几个 hash 算法后得到的值跟数组中对应位置的值对比发现都为 1 时，就判断这个 key 在集合中。</p>
<p>17、简述Redis事务实现 </p>
<p>​		Redis 事务：在事务失败时不进行回滚，而是继续执行余下的命令</p>
<p>​			1.开始事务 MULTI</p>
<p>​			2.命令入队</p>
<p>​			3.执行事务 EXEC</p>
<p>​			4.监控 WATCH：一个或者多个键，如果该键在事务执行期间修改，则事务不执行</p>
<p>​			5.取消监控 UNWATCH</p>
<h2 id="Kafka-构建TB级异步消息系统"><a href="#Kafka-构建TB级异步消息系统" class="headerlink" title="Kafka 构建TB级异步消息系统"></a>Kafka 构建TB级异步消息系统</h2><h3 id="Kafka-介绍与作用"><a href="#Kafka-介绍与作用" class="headerlink" title="Kafka 介绍与作用"></a>Kafka 介绍与作用</h3><p>​	kafka是一个分布式的流媒体平台，流处理是指对不断产生的动态数据流实时处理。</p>
<p>​	一般应用在消息系统（主流）、日志收集、用户行为跟踪、流式数据处理等方面。</p>
<p>·kafka术语</p>
<p>​	-Broker【kafka服务器，kafka集群中的每一台服务器都是一个Broker】、zookeeper</p>
<p>​	-Topic【主题】、Partition【分区】、一个主题有多个分区。Offset 偏移量【消息在分区	队列中的索引】</p>
<p>​	-Leader Replica【主副本：数据的备份，负责响应】、Follower Replica【从副本，从主副本备份数据】</p>
<h4 id="Kafaka的特性"><a href="#Kafaka的特性" class="headerlink" title="Kafaka的特性"></a>Kafaka的特性</h4><p>​	高吞吐量：处理TB级的海量数据；</p>
<p>​	消息持久化：持久化，将数据存储到硬盘上，而不仅仅存储在内存中，长久保存消息，存到硬盘中的读取速度远远小于内存，读写硬盘的效率高低取决于读取硬盘的方式，硬盘的顺序读写的效率是很高的（高于对内存的随机读写），kafka保证对硬盘消息的读取都是顺序的；</p>
<p>​	高可靠性：kafka是分布式部署，一台服务器挂了，还有别的，有容错机制；</p>
<p>​	高拓展性：集群的服务器不够时，可以扩展服务器，只需简单的配置。</p>
<h4 id="Kafka-与消息队列的实现方式"><a href="#Kafka-与消息队列的实现方式" class="headerlink" title="Kafka 与消息队列的实现方式"></a>Kafka 与消息队列的实现方式</h4><p>​		点对点的实现方式：BlockingQueue 阻塞队列，生产者将生产的消息放入队列中，消费者从队列中取出数据，每个消息只会被一个消费者消费；</p>
<p>​		发布订阅模式：生产者 Producer 将消息发布到某个主题中 Topic，多个消费者 Consumer 可以同时订阅这个位置，该消息可以被多个消费者读取。假如订阅者只有一个，那么和点对点的实现方式是一样的。</p>
<h3 id="Kafka-在论坛项目中的应用"><a href="#Kafka-在论坛项目中的应用" class="headerlink" title="Kafka 在论坛项目中的应用"></a>Kafka 在论坛项目中的应用</h3><p>本项目主要用到的是 Kafka 中的消息系统（基于消息队列）功能，即发送系统消息&#x2F;通知。</p>
<p>1、为数据库服务：</p>
<p>评论、点赞、关注时触发 Event，生产者发送消息到主题，消费者自动读取消息，封装成message，发送方id置为1，认为是系统发送的消息，存到数据库，这样就可以配合前端在用户被点赞关注时，得到通知。系统通知的消息非常多，使用消息队列进行削峰，避免直达数据库。</p>
<p>2、为ES服务</p>
<p>（1）在新建帖子，置顶，加精，评论帖子时，除了更新数据库的帖子的内容之外，也要将“发帖”为主题，发送到队列中，消费者得到帖子之后，让ES去做帖子的插入，覆盖ES中原有的帖子，防止ES中查到的数据不一致，同时也能减去ES对数据库的访问；</p>
<p>(2)删除帖子时，以“删帖”为主题，发送消息，消费者读取postId，让ES删掉帖子；</p>
<p>​		</p>
<p>​		当有点赞，评论，关注请求时，会发送系统通知给被点赞，评论，关注的对象。在处理系统信息时，使用到了Kafka，具体来说，先定义了生产者类和消费者类，其中生产者被点赞&#x2F;评论&#x2F;关注功能对应的 Controller 使用，产生消息。而消费者负责消息（message）到来时，把消息存到数据库内。 </p>
<p>生产者：触发Event，封装了Topic以及userId、Entity等信息，调用sendMsg时，提取出event.Topic和JSONObject.toJSONString(Event)以content形式发送，进行调用即可；</p>
<p>消费者：监听Topic，如果有新消息，就读取，record中获得到的是event里的json串，再恢复成event即可JSONObject.paresObject(record.value().toString,Event.class)；</p>
<p>然后将相关属性，封装成message私信的形式，保存到数据库中，供给前端页面调用并显示。</p>
<h3 id="Kafka-八股文"><a href="#Kafka-八股文" class="headerlink" title="Kafka 八股文"></a>Kafka 八股文</h3><h4 id="基础题目"><a href="#基础题目" class="headerlink" title="基础题目"></a>基础题目</h4><p>2、什么是消费者组?</p>
<p>消费者组是 Kafka 独有的概念，如果面试官问这个，就说明他对此是有一定了解的。我先给出标准答案：</p>
<p>1、定义：即消费者组是 Kafka 提供的可扩展且具有容错性的消费者机制。</p>
<p>2、原理：在 Kafka 中，消费者组是一个由多个消费者实例 构成的组。多个实例共同订阅若干个主题，实现共同消费。同一个组下的每个实例都配置有 相同的组 ID，被分配不同的订阅分区。当某个实例挂掉的时候，其他实例会自动地承担起 它负责消费的分区。</p>
<p>此时，又有一个小技巧给到你:消费者组的题目，能够帮你在某种程度上掌控下面的面试方向。</p>
<ul>
<li>如果你擅长位移值原理，就不妨再提一下消费者组的位移提交机制;</li>
<li>如果你擅长 Kafka     Broker，可以提一下消费者组与 Broker 之间的交互;</li>
<li>如果你擅长与消费者组完全不相关的     Producer，那么就可以这么说:“消费者组要消 费的数据完全来自于 Producer 端生产的消息，我对 Producer 还是比较熟悉的。”</li>
</ul>
<p>3、在 Kafka 中，ZooKeeper 的作用是什么?</p>
<p>这是一道能够帮助你脱颖而出的题目。碰到这个题目，请在心中暗笑三声。</p>
<p>目前，Kafka 使用 ZooKeeper 存放集群元数据、成员管理、Controller 选举，以及其他一些管理类任务。之后，等 KIP-500 提案完成后，Kafka 将完全不再依赖 于 ZooKeeper。</p>
<p>记住，一定要突出“目前”，以彰显你非常了解社区的演进计划。“存放元数据”是指主题 分区的所有数据都保存在 ZooKeeper 中，且以它保存的数据为权威，其他“人”都要与它 保持对齐。“成员管理”是指 Broker 节点的注册、注销以及属性变更，等 等。“Controller 选举”是指选举集群 Controller，而其他管理类任务包括但不限于主题 删除、参数配置等。</p>
<p>不过，抛出 KIP-500 也可能是个双刃剑。碰到非常资深的面试官，他可能会进一步追问你 KIP-500 是做的。一言以蔽之:KIP-500 思想，是使用社区自研的基于 Raft 的共识算法， 替代 ZooKeeper，实现 Controller 自选举。</p>
<p>4、解释下 Kafka 中位移(offset)的作用</p>
<p>在 Kafka 中，每个 主题分区下的每条消息都被赋予了一个唯一的 ID 数值，用于标识它在分区中的位置。这个 ID 数值，就被称为位移，或者叫偏移量。一旦消息被写入到分区日志，它的位移值将不能 被修改。</p>
<p>答完这些之后，你还可以把整个面试方向转移到你希望的地方。常见方法有以下 3 种:</p>
<ol>
<li>如果你深谙     Broker 底层日志写入的逻辑，可以强调下消息在日志中的存放格式;</li>
<li>如果你明白位移值一旦被确定不能修改，可以强调下“Log     Cleaner 组件都不能影响位 移值”这件事情;</li>
<li>如果你对消费者的概念还算熟悉，可以再详细说说位移值和消费者位移值之间的区别。</li>
</ol>
<p>5、阐述下 Kafka 中的领导者副本(Leader Replica)和追随者副本 (Follower Replica)的区别</p>
<p>这道题表面上是考核你对 Leader 和 Follower 区别的理解，但很容易引申到 Kafka 的同步 机制上。因此，我建议你主动出击，一次性地把隐含的考点也答出来，也许能够暂时把面试 官“唬住”，并体现你的专业性。</p>
<p>你可以这么回答:Kafka 副本当前分为领导者副本和追随者副本。只有 Leader 副本才能 对外提供读写服务，响应 Clients 端的请求。Follower 副本只是采用拉(PULL)的方 式，被动地同步 Leader 副本中的数据，并且在 Leader 副本所在的 Broker 宕机后，随时 准备应聘 Leader 副本。</p>
<p>通常来说，回答到这个程度，其实才只说了 60%，因此，我建议你再回答两个额外的加分 项。</p>
<ul>
<li>强调     Follower 副本也能对外提供读服务。自 Kafka 2.4 版本开始，社区通过引入新的 Broker 端参数，允许 Follower     副本有限度地提供读服务。</li>
<li>强调     Leader 和 Follower 的消息序列在实际场景中不一致。很多原因都可能造成 Leader 和 Follower 保存的消息序列不一致，比如程序     Bug、网络问题等。这是很严重 的错误，必须要完全规避。你可以补充下，之前确保一致性的主要手段是高水位机制， 但高水位值无法保证 Leader     连续变更场景下的数据一致性，因此，社区引入了 Leader Epoch 机制，来修复高水位值的弊端。关于“Leader Epoch     机制”，国内的资料不是 很多，它的普及度远不如高水位，不妨大胆地把这个概念秀出来，力求惊艳一把。</li>
</ul>
<h4 id="实操题目"><a href="#实操题目" class="headerlink" title="实操题目"></a>实操题目</h4><p>6、如何设置 Kafka 能接收的最大消息的大小?</p>
<p>这道题除了要回答消费者端的参数设置之外，一定要加上 Broker 端的设置，这样才算完整。毕竟，如果 Producer 都不能向 Broker 端发送数据很大的消息，又何来消费一说呢? 因此，你需要同时设置 Broker 端参数和 Consumer 端参数。</p>
<ul>
<li>Broker     端参数:message.max.bytes、max.message.bytes(主题级别)和 replica.fetch.max.bytes。</li>
<li>Consumer     端参数:fetch.message.max.bytes。</li>
</ul>
<p>Broker 端的最后一个参数比较容易遗漏。我们必须调整 Follower 副本能够接收的最大消 息的大小，否则，副本同步就会失败。因此，把这个答出来的话，就是一个加分项。</p>
<p>7、监控 Kafka 的框架都有哪些?</p>
<p>面试官其实是在 考察你对监控框架的了解广度，或者说，你是否知道很多能监控 Kafka 的框架或方法。下 面这些就是 Kafka 发展历程上比较有名气的监控系统。</p>
<ol>
<li>Kafka Manager:应该算是最有名的专属 Kafka 监控框架了，是独立的监控系统。</li>
<li>Kafka Monitor:LinkedIn     开源的免费框架，支持对集群进行系统测试，并实时监控测<br>      试结果。</li>
<li>CruiseControl:也是 LinkedIn     公司开源的监控框架，用于实时监测资源使用率，以及 提供常用运维操作等。无 UI 界面，只提供 REST API。</li>
<li>JMX 监控:由于 Kafka 提供的监控指标都是基于 JMX     的，因此，市面上任何能够集成 JMX 的框架都可以使用，比如 Zabbix 和 Prometheus。</li>
<li>已有大数据平台自己的监控体系:像 Cloudera 提供的 CDH     这类大数据平台，天然就提 供 Kafka 监控方案。</li>
<li>JMXTool:社区提供的命令行工具，能够实时监控 JMX     指标。答上这一条，属于绝对 的加分项，因为知道的人很少，而且会给人一种你对 Kafka 工具非常熟悉的感觉。如果     你暂时不了解它的用法，可以在命令行以无参数方式执行一下kafka-run-class.sh kafka.tools.JmxTool，学习下它的用法。</li>
</ol>
<p>8、Broker 的 Heap Size 如何设置?</p>
<p>如何设置 Heap Size 的问题，其实和 Kafka 关系不大，它是一类非常通用的面试题目。一 旦你应对不当，面试方向很有可能被引到 JVM 和 GC 上去，那样的话，你被问住的几率就 会增大。因此，我建议你简单地介绍一下 Heap Size 的设置方法，并把重点放在 Kafka Broker 堆大小设置的最佳实践上。</p>
<p>比如，你可以这样回复:任何 Java 进程 JVM 堆大小的设置都需要仔细地进行考量和测 试。一个常见的做法是，以默认的初始 JVM 堆大小运行程序，当系统达到稳定状态后，手动触发一次 Full GC，然后通过 JVM 工具查看 GC 后的存活对象大小。之后，将堆大小设 置成存活对象总大小的 1.5~2 倍。对于 Kafka 而言，这个方法也是适用的。不过，业界有 个最佳实践，那就是将 Broker 的 Heap Size 固定为 6GB。经过很多公司的验证，这个大 小是足够且良好的。</p>
<p>9、如何估算 Kafka 集群的机器数量?</p>
<p>这道题目考查的是机器数量和所用资源之间的关联关系。所谓资源，也就是 CPU、内存、磁盘和带宽。</p>
<p>通常来说，CPU 和内存资源的充足是比较容易保证的，因此，你需要从磁盘空间和带宽占用两个维度去评估机器数量。</p>
<p>在预估磁盘的占用时，你一定不要忘记计算副本同步的开销。如果一条消息占用 1KB 的磁 盘空间，那么，在有 3 个副本的主题中，你就需要 3KB 的总空间来保存这条消息。显式地 将这些考虑因素答出来，能够彰显你考虑问题的全面性，是一个难得的加分项。</p>
<p>对于评估带宽来说，常见的带宽有 1Gbps 和 10Gbps，但你要切记，这两个数字仅仅是最大值。因此，你最好和面试官确认一下给定的带宽是多少。然后，明确阐述出当带宽占用接 近总带宽的 90% 时，丢包情形就会发生。这样能显示出你的网络基本功。</p>
<p>10、Leader 总是 -1，怎么破?</p>
<p>在生产环境中，你一定碰到过“某个主题分区不能工作了”的情形。使用命令行查看状态的 话，会发现 Leader 是 -1，于是，你使用各种命令都无济于事，最后只能用“重启大 法”。</p>
<p>但是，有没有什么办法，可以不重启集群，就能解决此事呢?这就是此题的由来。</p>
<p>我直接给答案:删除 ZooKeeper 节点 &#x2F;controller，触发 Controller 重选举。 Controller 重选举能够为所有主题分区重刷分区状态，可以有效解决因不一致导致的 Leader 不可用问题。我几乎可以断定，当面试官问出此题时，要么就是他真的不知道怎么 解决在向你寻求答案，要么他就是在等你说出这个答案。所以，千万别一上来就说“来个重 启”之类的话。</p>
<h4 id="炫技式题目"><a href="#炫技式题目" class="headerlink" title="炫技式题目"></a>炫技式题目</h4><p>11、LEO、LSO、AR、ISR、HW 都表示什么含义?</p>
<ul>
<li>LEO:Log End     Offset。日志末端位移值或末端偏移量，表示日志下一条待插入消息的 位移值。举个例子，如果日志有 10 条消息，位移值从 0 开始，那么，第 10     条消息的位 移值就是 9。此时，LEO &#x3D; 10。</li>
<li>LSO:Log Stable     Offset。这是 Kafka 事务的概念。如果你没有使用到事务，那么这个     值不存在(其实也不是不存在，只是设置成一个无意义的值)。该值控制了事务型消费 者能够看到的消息范围。它经常与 Log Start     Offset，即日志起始位移值相混淆，因为 有些人将后者缩写成 LSO，这是不对的。在 Kafka 中，LSO 就是指代 Log Stable     Offset。</li>
<li>AR:Assigned     Replicas。AR 是主题被创建后，分区创建时被分配的副本集合，副本个 数由副本因子决定。</li>
<li>ISR:In-Sync     Replicas。Kafka 中特别重要的概念，指代的是 AR 中那些与 Leader 保 持同步的副本集合。在 AR 中的副本可能不在 ISR     中，但 Leader 副本天然就包含在 ISR 中。关于 ISR，还有一个常见的面试题目是如何判断副本是否应该属于     ISR。目前的判断     依据是:Follower 副本的 LEO 落后 Leader LEO 的时间，是否超过了 Broker 端参数     replica.lag.time.max.ms 值。如果超过了，副本就会被从 ISR 中移除。</li>
<li>HW:高水位值(High     watermark)。这是控制消费者可读取消息范围的重要字段。一 个普通消费者只能“看到”Leader 副本上介于 Log Start Offset     和 HW(不含)之间的 所有消息。水位以上的消息是对消费者不可见的。关于 HW，问法有很多，我能想到的 最高级的问法，就是让你完整地梳理下     Follower 副本拉取 Leader 副本、执行同步机制 的详细步骤。这就是我们的第 20 道题的题目，一会儿我会给出答案和解析。</li>
</ul>
<p>12、Kafka 能手动删除消息吗?</p>
<p>其实，Kafka 不需要用户手动删除消息。它本身提供了留存策略，能够自动删除过期消息。 当然，它是支持手动删除消息的。因此，你最好从这两个维度去回答。</p>
<ul>
<li>对于设置了 Key 且参数     cleanup.policy&#x3D;compact 的主题而言，我们可以构造一条 &lt;Key，null&gt; 的消息发送给 Broker，依靠     Log Cleaner 组件提供的功能删除掉该 Key 的消息。</li>
<li>对于普通主题而言，我们可以使用     kafka-delete-records 命令，或编写程序调用 Admin.deleteRecords     方法来删除消息。这两种方法殊途同归，底层都是调用 Admin 的 deleteRecords 方法，通过将分区 Log Start Offset     值抬高的方式间接删除消息。</li>
</ul>
<p>13、__consumer_offsets 是做什么用的?</p>
<p>这是一个内部主题，公开的官网资料很少涉及到。因此，我认为，此题属于面试官炫技一类 的题目。你要小心这里的考点:该主题有 3 个重要的知识点，你一定要全部答出来，才会显得对这块知识非常熟悉。</p>
<p>它是一个内部主题，无需手动干预，由 Kafka 自行管理。当然，我们可以创建该主题。</p>
<p>它的主要作用是负责注册消费者以及保存位移值。可能你对保存位移值的功能很熟悉， 但其实该主题也是保存消费者元数据的地方。千万记得把这一点也回答上。另外，这里 的消费者泛指消费者组和独立消费者，而不仅仅是消费者组。</p>
<p>Kafka 的 GroupCoordinator 组件提供对该主题完整的管理功能，包括该主题的创建、 写入、读取和 Leader 维护等。</p>
<p>14、分区 Leader 选举策略有几种?</p>
<p>分区的 Leader 副本选举对用户是完全透明的，它是由 Controller 独立完成的。你需要回答的是，在哪些场景下，需要执行分区 Leader 选举。每一种场景对应于一种选举策略。当前，Kafka 有 4 种分区 Leader 选举策略。</p>
<ul>
<li>OfflinePartition     Leader 选举:每当有分区上线时，就需要执行     Leader 选举。所谓的分区上线，可能是创建了新分区，也可能是之前的下线分区重新上线。这是最常见的分区 Leader 选举场景。</li>
<li>ReassignPartition     Leader 选举:当你手动运行     kafka-reassign-partitions 命令，或者是调用 Admin 的 alterPartitionReassignments     方法执行分区副本重分配时，可能触发此类选举。假设原来的 AR 是[1，2，3]，Leader 是 1，当执行副本重分配后，副本集 合 AR     被设置成[4，5，6]，显然，Leader 必须要变更，此时会发生 Reassign Partition Leader 选举。</li>
<li>PreferredReplicaPartition     Leader 选举:当你手动运行     kafka-preferred-replica- election 命令，或自动触发了 Preferred Leader     选举时，该类策略被激活。所谓的 Preferred Leader，指的是 AR 中的第一个副本。比如 AR 是[3，2，1]，那么，     Preferred Leader 就是 3。</li>
<li>ControlledShutdownPartition     Leader 选举:当     Broker 正常关闭时，该 Broker 上 的所有 Leader 副本都会下线，因此，需要为受影响的分区执行相应的 Leader 选举。</li>
</ul>
<p>这 4 类选举策略的大致思想是类似的，即从 AR 中挑选首个在 ISR 中的副本，作为新 Leader。当然，个别策略有些微小差异。不过，回答到这种程度，应该足以应付面试官 了。毕竟，微小差别对选举 Leader 这件事的影响很小。</p>
<p>15、Kafka 的哪些场景中使用了零拷贝(Zero Copy)?</p>
<p>Zero Copy 是特别容易被问到的高阶题目。在 Kafka 中，体现 Zero Copy 使用场景的地方有两处:基于 mmap 的索引和日志文件读写所用的 TransportLayer。</p>
<p>先说第一个。索引都是基于 MappedByteBuffer 的，也就是让用户态和内核态共享内核态 的数据缓冲区，此时，数据不需要复制到用户态空间。不过，mmap 虽然避免了不必要的 拷贝，但不一定就能保证很高的性能。在不同的操作系统下，mmap 的创建和销毁成本可 能是不一样的。很高的创建和销毁开销会抵消 Zero Copy 带来的性能优势。由于这种不确 定性，在 Kafka 中，只有索引应用了 mmap，最核心的日志并未使用 mmap 机制。</p>
<p>再说第二个。TransportLayer 是 Kafka 传输层的接口。它的某个实现类使用了 FileChannel 的 transferTo 方法。该方法底层使用 sendfile 实现了 Zero Copy。对 Kafka 而言，如果 I&#x2F;O 通道使用普通的 PLAINTEXT，那么，Kafka 就可以利用 Zero Copy 特 性，直接将页缓存中的数据发送到网卡的 Buffer 中，避免中间的多次拷贝。相反，如果 I&#x2F;O 通道启用了 SSL，那么，Kafka 便无法利用 Zero Copy 特性了。</p>
<h4 id="深度思考题"><a href="#深度思考题" class="headerlink" title="深度思考题"></a>深度思考题</h4><p>16、Kafka 为什么不支持读写分离?</p>
<p>这道题目考察的是你对 Leader&#x2F;Follower 模型的思考。</p>
<p>Leader&#x2F;Follower 模型并没有规定 Follower 副本不可以对外提供读服务。很多框架都是允 许这么做的，只是 Kafka 最初为了避免不一致性的问题，而采用了让 Leader 统一提供服 务的方式。</p>
<p>不过，在开始回答这道题时，你可以率先亮出观点:自 Kafka 2.4 之后，Kafka 提供了有限度的读写分离，也就是说，Follower 副本能够对外提供读服务。</p>
<p>说完这些之后，你可以再给出之前的版本不支持读写分离的理由。</p>
<ul>
<li>场景不适用。读写分离适用于那种读负载很大，而写操作相对不频繁的场景，可     Kafka 不属于这样的场景。</li>
<li>同步机制。Kafka 采用 PULL 方式实现     Follower 的同步，因此，Follower 与 Leader 存 在不一致性窗口。如果允许读 Follower     副本，就势必要处理消息滞后(Lagging)的问题。</li>
</ul>
<p>17、如何调优 Kafka?</p>
<p>回答任何调优问题的第一步，就是确定优化目标，并且定量给出目标!这点特别重要。对于 Kafka 而言，常见的优化目标是吞吐量、延时、持久性和可用性。每一个方向的优化思路都 是不同的，甚至是相反的。</p>
<p>确定了目标之后，还要明确优化的维度。有些调优属于通用的优化思路，比如对操作系统、 JVM 等的优化;有些则是有针对性的，比如要优化 Kafka 的 TPS。我们需要从 3 个方向去考虑</p>
<ul>
<li>Producer     端:增加     batch.size、linger.ms，启用压缩，关闭重试等。</li>
<li>Broker     端:增加     num.replica.fetchers，提升 Follower 同步 TPS，避免 Broker Full GC 等。</li>
<li>Consumer:增加 fetch.min.bytes     等</li>
</ul>
<p>18、Controller 发生网络分区(Network Partitioning)时，Kafka 会怎 么样?</p>
<p>这道题目能够诱发我们对分布式系统设计、CAP 理论、一致性等多方面的思考。不过，针 对故障定位和分析的这类问题，我建议你首先言明“实用至上”的观点，即不论怎么进行理论分析，永远都要以实际结果为准。一旦发生 Controller 网络分区，那么，第一要务就是 查看集群是否出现“脑裂”，即同时出现两个甚至是多个 Controller 组件。这可以根据 Broker 端监控指标 ActiveControllerCount 来判断。</p>
<p>现在，我们分析下，一旦出现这种情况，Kafka 会怎么样。</p>
<p>由于 Controller 会给 Broker 发送 3 类请求，即LeaderAndIsrRequest、 StopReplicaRequest 和 UpdateMetadataRequest，因此，一旦出现网络分区，这些请求将不能顺利到达 Broker 端。这将影响主题的创建、修改、删除操作的信息同步，表现为 集群仿佛僵住了一样，无法感知到后面的所有操作。因此，网络分区通常都是非常严重的问 题，要赶快修复。</p>
<p>19、Java Consumer 为什么采用单线程来获取消息?</p>
<p>在回答之前，如果先把这句话说出来，一定会加分:Java Consumer 是双线程的设计。一 个线程是用户主线程，负责获取消息;另一个线程是心跳线程，负责向 Kafka 汇报消费者 存活情况。将心跳单独放入专属的线程，能够有效地规避因消息处理速度慢而被视为下线 的“假死”情况。</p>
<p>单线程获取消息的设计能够避免阻塞式的消息获取方式。单线程轮询方式容易实现异步非阻塞式，这样便于将消费者扩展成支持实时流处理的操作算子。因为很多实时流处理操作算子都不能是阻塞式的。另外一个可能的好处是，可以简化代码的开发。多线程交互的代码是非常容易出错的。</p>
<p>20、简述 Follower 副本消息同步的完整流程</p>
<p>首先，Follower 发送 FETCH 请求给 Leader。接着，Leader 会读取底层日志文件中的消 息数据，再更新它内存中的 Follower 副本的 LEO 值，更新为 FETCH 请求中的 fetchOffset 值。最后，尝试更新分区高水位值。Follower 接收到 FETCH 响应之后，会把 消息写入到底层日志，接着更新 LEO 和 HW 值。</p>
<p>Leader 和 Follower 的 HW 值更新时机是不同的，Follower 的 HW 更新永远落后于 Leader 的 HW。这种时间上的错配是造成各种不一致的原因。</p>
<h2 id="Elasticsearch-分布式搜索引擎"><a href="#Elasticsearch-分布式搜索引擎" class="headerlink" title="Elasticsearch 分布式搜索引擎"></a>Elasticsearch 分布式搜索引擎</h2><h3 id="ES-介绍与作用"><a href="#ES-介绍与作用" class="headerlink" title="ES 介绍与作用"></a>ES 介绍与作用</h3><p>ES是一个基于 lucene 构建的，分布式的，由多个节点构成集群，RESTful的开源全文搜索引擎。</p>
<p>​	存储原理：数据按照 Index 索引– Type 类型（6.0之后逐渐废弃） – Document 文档 – 字段 四级存储。6.0 之后的其中 Index 对应表，Document 为搜索的原子单位，包含一个或多个容器，基于 JSON 表示，类似于数据库中的行。字段是指 JSON 中的每一项组成，类似于数据库中的列。 Mapping 是文档分 析过滤后的结果，根据用户自定义，将某些文字过滤掉，类似于表结构定义 DDL。同时 ES 也和分布式数据库一样，支持 shard 分片 的 replication 分段。</p>
<p>​	集群【分布式部署，集群是指多台服务器协助工作，提高整体性能】、节点【集群中的每一台服务器】、分片【一个索引拆分成多个分片，提高并发能力】、副本【分片的备份，提高可用性】</p>
<p>​	索引：MySQL 的 B+ 树 与 ES 的单排索引 比较</p>
<p>因为Elasticsearch最核心功能是搜索，所以查询的速度最重要，而插入&#x2F;更新数据的速度是次要的。</p>
<p>功能：</p>
<p>1、分布式的搜索引擎和数据分析引擎。</p>
<p>2、全文检索，结构化检索，数据分析。</p>
<p>3、对海量数据进行近实时的处理。</p>
<p>特点：准实时</p>
<p>1、可以作为分布式集群处理PB级别的数据，也可单机使用。</p>
<p>2、不是特有技术，而是将分布式+全文搜索（lucene) + 数据分析合并在一起。</p>
<p>3、操作简单，作为传统数据库的补充，提供了数据库所不具备的很多功能。</p>
<h3 id="ES-在论坛项目中的应用"><a href="#ES-在论坛项目中的应用" class="headerlink" title="ES 在论坛项目中的应用"></a>ES 在论坛项目中的应用</h3><p>​		ES 服务器数据同步：发布帖子或增加评论时，采用异步的方式（提高性能）提交到 ES 服务器，当发帖评论触发事件时，生产者直接将事件丢到消息队列，就可以去处理另外的事；在消费组件中增加方法（标注 @KafkaListener(topics &#x3D; {发帖&#x2F;评论})），就可以消费帖子发布和评论发布事件。即使用消息队列（kafka）的方式，实现发帖&#x2F;删帖后 ES 数据库的自动更新。</p>
<p>​		在进行帖子搜索时，使用到了 ES。可用 Repository 和 Template 两种方式，由于 Repository 搜索到的结果（直接返回的 post 类，方便）没有高亮标签（why），所以使用了 template 方式重写了 mapResults 函数，获得了带有高亮标签的 post。</p>
<p>​	搜索：定义 SearchQuery，确定搜素内容，排序方式，高亮等。接着使用 elasticTemplate.queryForPage 方法，需要重写mapResults 函数，得到高亮数据。</p>
<h3 id="ES-八股文"><a href="#ES-八股文" class="headerlink" title="ES 八股文"></a>ES 八股文</h3><p>1.为什么要使用Elasticsearch?</p>
<p>因为在我们商城中的数据，将来会非常多，所以采用以往的模糊查询，模糊查询前置配置，会放弃索引，导致商品查询是全表扫面，在百万级别的数据库中，效率非常低下，而我们使用ES做一个全文索引，我们将经常查询的商品的某些字段，比如说商品名，描述、价格还有id这些字段我们放入我们索引库里，可以提高查询速度。</p>
<p>2.Elasticsearch是如何实现Master选举的？</p>
<p>Elasticsearch的选主是ZenDiscovery模块负责的，主要包含Ping（节点之间通过这个RPC来发现彼此）和Unicast（单播模块包含一个主机列表以控制哪些节点需要ping通）这两部分；</p>
<p>对所有可以成为master的节点（node.master: true）根据nodeId字典排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是master节点。</p>
<p>如果对某个节点的投票数达到一定的值（可以成为master节点数n&#x2F;2+1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举一直到满足上述条件。</p>
<p>补充：master节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理；data节点可以关闭http功能。</p>
<p>3.Elasticsearch中的节点（比如共20个），其中的10个选了一个master，另外10个选了另一个master，怎么办？</p>
<p>当集群master候选数量不小于3个时，可以通过设置最少投票通过数量（discovery.zen.minimum_master_nodes）超过所有候选节点一半以上来解决脑裂问题；</p>
<p>当候选数量为两个时，只能修改为唯一的一个master候选，其他作为data节点，避免脑裂问题。</p>
<p>4.详细描述一下Elasticsearch索引文档的过程。</p>
<p>协调节点默认使用文档ID参与计算（也支持通过routing），以便为路由提供合适的分片。</p>
<p>shard &#x3D; hash(document_id) % (num_of_primary_shards)</p>
<p>当分片所在的节点接收到来自协调节点的请求后，会将请求写入到Memory Buffer，然后定时（默认是每隔1秒）写入到Filesystem Cache，这个从Momery Buffer到Filesystem 　Cache的过程就叫做refresh；</p>
<p>当然在某些情况下，存在Momery Buffer和Filesystem Cache的数据可能会丢失，ES是通过translog的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到translog中，当Filesystem cache中的数据写入到磁盘中时，才会清除掉，这个过程叫做flush；</p>
<p>在flush过程中，内存中的缓冲将被清除，内容被写入一个新段，段的fsync将创建一个新的提交点，并将内容刷新到磁盘，旧的translog将被删除并开始一个新的translog。</p>
<p>flush触发的时机是定时触发（默认30分钟）或者translog变得太大（默认为512M）时；</p>
<p>5.详细描述一下Elasticsearch更新和删除文档的过程</p>
<p>删除和更新也都是写操作，但是Elasticsearch中的文档是不可变的，因此不能被删除或者改动以展示其变更；</p>
<p>磁盘上的每个段都有一个相应的.del文件。当删除请求发送后，文档并没有真的被删除，而是在.del文件中被标记为删除。该文档依然能匹配查询，但是会在结果中被过滤掉。当段合并时，在.del文件中被标记为删除的文档将不会被写入新段。</p>
<p>在新的文档被创建时，Elasticsearch会为该文档指定一个版本号，当执行更新时，旧版本的文档在.del文件中被标记为删除，新版本的文档被索引到一个新段。旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。</p>
<p>6.详细描述一下Elasticsearch搜索的过程</p>
<p>搜索被执行成一个两阶段过程，我们称之为 Query Then Fetch；</p>
<p>在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。 每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的优先队列。PS：在搜索的时候是会查询Filesystem Cache的，但是有部分数据还在Memory Buffer，所以搜索是近实时的。</p>
<p>每个分片返回各自优先队列中 所有文档的 ID 和排序值 给协调节点，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。</p>
<p>接下来就是 取回阶段，协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。每个分片加载并 丰富 文档，如果有需要的话，接着返回文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端。</p>
<p>补充：Query Then Fetch的搜索类型在文档相关性打分的时候参考的是本分片的数据，这样在文档数量较少的时候可能不够准确，DFS Query Then Fetch增加了一个预查询的处理，询问Term和Document frequency，这个评分更准确，但是性能会变差。</p>
<p>9.Elasticsearch对于大数据量（上亿量级）的聚合如何实现？</p>
<p>Elasticsearch 提供的首个近似聚合是cardinality 度量。它提供一个字段的基数，即该字段的distinct或者unique值的数目。它是基于HLL算法的。HLL 会先对我们的输入作哈希运算，然后根据哈希运算的结果中的 bits 做概率估算从而得到基数。其特点是：可配置的精度，用来控制内存的使用（更精确 ＝ 更多内存）；小的数据集精度是非常高的；我们可以通过配置参数，来设置去重需要的固定内存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关 .</p>
<p>10.在并发情况下，Elasticsearch如果保证读写一致？</p>
<p>可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；</p>
<p>另外对于写操作，一致性级别支持quorum&#x2F;one&#x2F;all，默认为quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。</p>
<p>对于读操作，可以设置replication为sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；如果设置replication为async时，也可以通过设置搜索请求参数_preference为primary来查询主分片，确保文档是最新版本。</p>
<p>14.ElasticSearch中的集群、节点、索引、文档、类型是什么？</p>
<p>群集是一个或多个节点（服务器）的集合，它们共同保存您的整个数据，并提供跨所有节点的联合索引和搜索功能。群集由唯一名称标识，默认情况下为“elasticsearch”。此名称很重要，因为如果节点设置为按名称加入群集，则该节点只能是群集的一部分。</p>
<p>节点是属于集群一部分的单个服务器。它存储数据并参与群集索引和搜索功能。</p>
<p>索引就像关系数据库中的“数据库”。它有一个定义多种类型的映射。索引是逻辑名称空间，映射到一个或多个主分片，并且可以有零个或多个副本分片。 MySQL &#x3D;&gt;数据库 　　     ElasticSearch &#x3D;&gt;索引</p>
<p>文档类似于关系数据库中的一行。不同之处在于索引中的每个文档可以具有不同的结构（字段），但是对于通用字段应该具有相同的数据类型。 MySQL &#x3D;&gt; Databases &#x3D;&gt;        Tables &#x3D;&gt; Columns &#x2F; Rows ElasticSearch &#x3D;&gt; Indices &#x3D;&gt; Types &#x3D;&gt;具有属性的文档</p>
<p>类型是索引的逻辑类别&#x2F;分区，其语义完全取决于用户。</p>
<p>15.ElasticSearch中的分片是什么?</p>
<p>在大多数环境中，每个节点都在单独的盒子或虚拟机上运行。</p>
<p>索引 - 在Elasticsearch中，索引是文档的集合。</p>
<p>分片 -因为Elasticsearch是一个分布式搜索引擎，所以索引通常被分割成分布在多个节点上的被称为分片的元素。</p>
<h1 id="测试与测开"><a href="#测试与测开" class="headerlink" title="测试与测开"></a>测试与测开</h1><h2 id="JMeter-压力测试工具"><a href="#JMeter-压力测试工具" class="headerlink" title="JMeter 压力测试工具"></a>JMeter 压力测试工具</h2><p>使用工具模拟多个客户端访问服务器，查看性能。</p>
<p><img src="/../imags/image-20220817163044027.png" alt="image-20220817163044027"></p>
<p>1、创建线程组，用来模拟多个用户</p>
<p>2、创建 HTTP 请求，用于访问某功能</p>
<p>3、添加定时器，用于添加时间间隔否则服务器容易宕机</p>
<p>4、聚合报告，主要看吞吐量（处理多少请求&#x2F;s）</p>
<p>优化前 10 左右的吞吐量，优化后（对网站性能优化采用：本地缓存+分布式缓存方案）达到了 190 左右的吞吐量。</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>每次的测试步骤：初始化数据、执行测试代码、验证测试结果、清理测试数据</p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>1、开发项目时需要的难点，怎么解决</p>
<p>2、开发项目需要的 BUG ，怎么解决</p>
<p>1、请简要介绍一下你的项目</p>
<p>​		本项目是为了我们学校研究生学院方便学术交流和生活分享的平台。主要使用了Spring Boot、Mybatis、MySQL、Redis、kafka等工具，实现了用户的注册、登录、点赞、评论、系统通知、热度排行、搜索等功能，使用Redis提升了网站的性能，实现了用户凭证的存取、点赞关注的功能。基于 Kafka 实现了系统通知功能，当用户获得点赞、评论后得到通知。利用定时任务定期计算帖子的分数，并在页面上展现热帖排行榜。</p>
<p>2、什么是 Spring 框架？</p>
<p>​		Spring框架是集成了多个模块，利用这些模块能方便开发工作。比如有核心容器、Spring JDBC、Web、AOP、消息模块、Spring Test等。</p>
<p>3、对Spring AOP 和 IOC 的理解</p>
<p>​		IOC（Inverse of Control:控制反转）：IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。</p>
<p>​		为什么叫控制反转：1.控制：控制对象实例化的权力；2.反转：把控制权交给Spring框架、IOC容器</p>
<p>​		AOP(Aspect-Oriented Programming:面向切面编程)：因为诸如日志，权限，事务，性能监测等业务几乎涉及到了所有的核心模块，如果把这些特殊的业务代码直接到核心业务模块的代码中就会造成代码混乱、代码冗余、耦合度高等问题。AOP 能够将那些与业务无关，却为业务模块所共同调用的逻辑代码（例如事务处理、日志管理、权限控制等）封装起来。便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<p>​		服务器分为表现层、业务层、数据层。而Spring MVC是表现层的框架，主要作用是接受并解析客户端发来的请求，</p>
<p>5、项目中怎样用Redis做高并发</p>
<p>6、如果 Redis 启动协程更新数据到数据库失败了怎么处理 </p>
<p>7、登录怎么做的？</p>
<p>​	根据请求来拆解功能</p>
<p>​		1，打开注册网页</p>
<p>​		2，把注册的信息发送给服务器（点注册）</p>
<p>​		3，把激活邮件发送给邮箱</p>
<p>​		4，利用激活链接打开网页</p>
<p>​	每一次请求都是先开发数据访问层，在开发业务层，最后开发视图层（三层架构），但是每一次请求不一定要用到这三层</p>
<p>8、Spring MVC是什么，是怎样的工作流程？</p>
<p>​		Spring MVC是工作在表现层，根据用户的请求调用service服务，serivece调用dao连接数据库。</p>
<p>​		在整个 Spring MVC 框架中，DispatcherServlet 处于核心位置，它负责协调和组织不同组件完成请求处理并返回响应工作。</p>
<p>9、你的项目能承受的流量是多少？Qps是多少？如何优化的？项目能支撑多高的访问量？</p>
<p>10、使用什么技术生成验证码?</p>
<p>​		使用Kaptcha包，可随机生成字符和图片。</p>
<p>11、如何实现敏感词过滤？</p>
<p>​		1、使用前缀树（字典树）存储敏感词；2、跳过特殊字符：使用CharUtils工具类中判断是否为特殊字符；3、对 text 中的敏感词实现替换。</p>
<p>​		前缀树实现：根节点为空，叶子节点存放字符。声明三个指针，分别指向前缀树的根节点以及待处理的字符串。</p>
<p>12、项目中Redis的作用？用什么数据结构存的？</p>
<p>​		1.存储验证码；2.存储登录凭证；3.缓存用户信息；4.对zset需要排序的数据进行自定义排序</p>
<p>13、怎样存储的点赞&#x2F;关注&#x2F;缓存用户数据？</p>
<p>​		点赞使用set类型存储，key为点赞对象，set中保存点赞人的ID</p>
<p>​		关注使用zSet类型存储，key为被关注者，set保存关注者以及关注时间为score</p>
<p>​		缓存用户数据使用Value类型，key为用userID得到的key，value为user对象（设置过期时间，且数据修改时需要清除缓存）</p>
<p>14、什么是消息队列？</p>
<p>​		是一个存放消息的容器，生产者把消息放在队列中，消费者从消息队列中取出数据。好处是解耦，异步，限流。</p>
<p>15、什么是Kafka，有哪些功能和应用场景？</p>
<p>​		Kafka是一种消息队列，主要用来处理大量数据状态下的消息队列，一般用来做日志的处理。项目：当有点赞，评论关注请求时，会发送系统通知点赞，评论，关注的对象。</p>
<p>​		处理系统信息时，使用到了Kafka。即生产者被点赞，评论，关注功能对应的controller使用，产生消息；而消费者负责消息到来时，存到数据库。</p>
<p>16、怎样统计网站UA和DAU？</p>
<p>​		使用Redis的高级数据结构：</p>
<p>​		HyperLogLog：超级日志，统计独立整数个数。统计UA（独立访问）时，以日期为 rediskey ，将客户端IP　add 到HyperLogLog中（redisTemplate.opsForHyperLogLog().add(redisKey, i);）</p>
<p>​		Bitmap：位图，比如365天的签到，只需要３６５／８个字节的大小。统计DAU（日活跃用户）时，以日期为 rediskey ，以用户ID作为位（在数据中的位置），用 or 操作，既可以方便的统计一段时间内的注册用户访问人数。</p>
<p>17、Elasticsearch 与数据库的数据怎么同步</p>
<p>​		当发帖评论触发事件时，生产者直接将事件丢到消息队列，就可以去处理另外的事；在消费组件中增加方法（标注 @KafkaListener(topics &#x3D; {发帖&#x2F;评论})），就可以消费帖子发布和评论发布事件。即使用消息队列（kafka）的方式，实现发帖&#x2F;删帖后 ES 数据库的自动更新。</p>
<p>18、项目中的优化点，优化的具体场景，展开讲讲</p>
<p>19、Kafka怎么用的，消息队列的优缺点</p>
<p>20、Redis的数据结构有哪些，各自的设计思想是什么</p>
<p>​		String、Set、List、ZSet、HyperLogLog、Bitmap</p>
<p>21、优化网站的性能</p>
<p>​	本地缓存：数据缓存在应用服务器上，Caffeine&#x2F;Guava等工具</p>
<p>​	分布式缓存：数据存在 NoSQL 数据库上，Redis&#x2F;MemCache等工具</p>
<p>​	多级缓存：请求先查询–&gt;一级缓存–&gt;二级缓存–&gt;DB。数据库查到数据，存到二级缓存一级缓存再返回数据。两级缓存能避免缓存雪崩（只有当两级缓存同时失效，大量直接才会直接请求到 DB，导致 DB 瘫痪，概率很低）。</p>
<p>22、拦截器的作用？</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>TT
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2022/07/29/%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/" title="论坛项目">http://example.com/2022/07/29/论坛项目/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%A1%B9%E7%9B%AE/" rel="tag"># 项目</a>
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/MySQL/" rel="tag"># MySQL</a>
              <a href="/tags/Spring-Boot/" rel="tag"># Spring Boot</a>
              <a href="/tags/SSM/" rel="tag"># SSM</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/26/hello-world/" rel="prev" title="Hello World">
      <i class="fa fa-chevron-left"></i> Hello World
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/08/11/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" rel="next" title="MySQL 知识点总结">
      MySQL 知识点总结 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93"><span class="nav-number">1.</span> <span class="nav-text">项目总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%80%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="nav-number">2.</span> <span class="nav-text">所用工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E4%B8%80%E7%AB%99%E5%BC%8F%E9%AB%98%E6%80%A7%E8%83%BD%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88"><span class="nav-number">2.1.</span> <span class="nav-text">Redis 一站式高性能存储方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%9C%E7%94%A8"><span class="nav-number">2.1.1.</span> <span class="nav-text">Redis 介绍与作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E5%9C%A8%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">2.1.2.</span> <span class="nav-text">Redis 在论坛项目中的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">2.1.3.</span> <span class="nav-text">Redis 数据类型在项目中的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E5%85%AB%E8%82%A1%E6%96%87"><span class="nav-number">2.1.4.</span> <span class="nav-text">Redis 八股文</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka-%E6%9E%84%E5%BB%BATB%E7%BA%A7%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.2.</span> <span class="nav-text">Kafka 构建TB级异步消息系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Kafka-%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%9C%E7%94%A8"><span class="nav-number">2.2.1.</span> <span class="nav-text">Kafka 介绍与作用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafaka%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">Kafaka的特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka-%E4%B8%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">Kafka 与消息队列的实现方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kafka-%E5%9C%A8%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">2.2.2.</span> <span class="nav-text">Kafka 在论坛项目中的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kafka-%E5%85%AB%E8%82%A1%E6%96%87"><span class="nav-number">2.2.3.</span> <span class="nav-text">Kafka 八股文</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">基础题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E6%93%8D%E9%A2%98%E7%9B%AE"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">实操题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%82%AB%E6%8A%80%E5%BC%8F%E9%A2%98%E7%9B%AE"><span class="nav-number">2.2.3.3.</span> <span class="nav-text">炫技式题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%83%E9%A2%98"><span class="nav-number">2.2.3.4.</span> <span class="nav-text">深度思考题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Elasticsearch-%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E"><span class="nav-number">2.3.</span> <span class="nav-text">Elasticsearch 分布式搜索引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ES-%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%9C%E7%94%A8"><span class="nav-number">2.3.1.</span> <span class="nav-text">ES 介绍与作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES-%E5%9C%A8%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">2.3.2.</span> <span class="nav-text">ES 在论坛项目中的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES-%E5%85%AB%E8%82%A1%E6%96%87"><span class="nav-number">2.3.3.</span> <span class="nav-text">ES 八股文</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%B5%8B%E5%BC%80"><span class="nav-number">3.</span> <span class="nav-text">测试与测开</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JMeter-%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="nav-number">3.1.</span> <span class="nav-text">JMeter 压力测试工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-number">3.2.</span> <span class="nav-text">单元测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">常见问题</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="TT"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">TT</p>
  <div class="site-description" itemprop="description">All troubles are self-inflicted.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/DDDDSG" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;DDDDSG" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/62531488?spm_id_from=333.1007.0.0" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;62531488?spm_id_from&#x3D;333.1007.0.0" rel="noopener" target="_blank"><i class="fa fa-bold fa-fw"></i>bilibili</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://javaguide.cn/" title="https:&#x2F;&#x2F;javaguide.cn&#x2F;" rel="noopener" target="_blank">JavaGuide</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.programmercarl.com/" title="https:&#x2F;&#x2F;www.programmercarl.com&#x2F;" rel="noopener" target="_blank">Leetcode-master</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TT</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">101k</span>
    
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:32</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  















  

  

  

</body>
</html>
